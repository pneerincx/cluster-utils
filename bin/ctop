#!/usr/bin/env perl

# ============================================================================
#  This is the SLURM port of ctop copyright 2014 University Medical Center Groningen.
#  Partially based on pbstop copyright 2002, 2003, 2004 University of Southern California.
#      http://www-rcf.usc.edu/~garrick/perl-PBS
#      Please send comments to garrick@usc.edu.
#      Site appears to be down...
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
#  See the GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# ============================================================================

#
# Configurable defaults.
#
# Don't change the defaults here.
# Make a config file instead; see ctop(1).
#
my $columns            = 48;       # Columns in grid
my $sleeptime          = 30;       # Seconds between refreshes
my $colorize           = 1;        # 1 or 0
my $color_by           = 'job';    # Assign color per job, user, qos or resources.
my $show_summary       = 1;        # 1 or 0
my $show_grid          = 1;        # 1 or 0
my $dense_grid         = 1;        # 1 or 0
my $show_queue         = 1;        # 1 or 0
my $show_qqueue        = 0;        # 1 or 0
my $show_jobs          = 1;        # 1 or 0
my $show_user          = 'all';    # Show only jobs for specific users.
my $show_node          = 'all';    # Show only jobs for specific nodes jobs.
my $show_job_id        = 'all';    # Show only jobs with specific job IDs.
my @show_cpu           = ('0');    # List of cpu numbers. No longer used and hardcoded to CPU0.
my @cluster            = ();       # Name of your cluster.The default should be specified in /etc/slurm/slurm.conf
                                   # This is not necessarily the same as the user interface (UI) host
                                   # on which you login to monitor/submit jobs. When empty we will try
                                   # $ENV{"SLURM_CLUSTER_NAME"}, ClusterName from the "scontrol show config" command 
                                   # or as a last resort the hostname of localhost hoping that machines is named after the cluster.
my $maxrows            = 3000;     # maximum number of rows.
my $maxcolumns         = 137;      # maximum number of columns to start with. 
                                   # May be increased on the fly when the job ID values are too long to fit within the default term width.
my $healthy_load_stdev = 3;        # When node load is lower or higher than requested/allocated cores Â± this stdev 
                                   # it is condidered inefficient or dangerous, respectively.
my $res_usage_low      = 0.80;     # When (used / requested) resources drops below this threshold it is considered inefficient.
my $res_usage_high     = 1.05;     # When (used / requested) resources exceeds this threshold it is considered dangerous.

my $squeue   = '/usr/bin/squeue';
my $sstat    = '/usr/bin/sstat';
my $scontrol = '/usr/bin/scontrol';
my $sinfo    = '/usr/bin/sinfo';

#########################################################
#   Nothing else to adjust below here
#########################################################

use strict;
use warnings;
use vars qw/$VERSION/;
use Curses;

$VERSION = "6.0.4";

#
# Initialize global vars.
#
my %job_of_letter;
my @colors = ();

#
# SLURM job states.
#
my %known_job_states=(
	'BF'  => {
				name => 'BOOT_FAIL',
				consumes_resources => 0,
				desc => 'Job terminated due to launch failure and can not be requeued. Typically the result of a hardware failure.'},
	'CA'  => {
				name => 'CANCELLED',
				consumes_resources => 0,
				desc => 'Job was explicitly cancelled by the user or a system administrator.'},
	'CD'  => {
				name => 'COMPLETED',
				consumes_resources => 0,
				desc => 'Job has finished and all processes had an exit code of zero.'},
	'CF'  => {
				name => 'CONFIGURING',
				consumes_resources => 1,
				desc => 'Job has been allocated resources and is waiting for them to come available/online.'},
	'CG'  => {
				name => 'COMPLETING',
				consumes_resources => 1,
				desc => 'Job is in the process of completing and cleaning up.'},
	'DL'  => {
				name => 'DEADLINE',
				consumes_resources => 0,
				desc => 'Job missed its deadline.'},
	'F'   => {
				name => 'FAILED',
				consumes_resources => 0,
				desc => 'Job terminated with non-zero exit code or other failure condition.'},
	'NF'  => {
				name => 'NODE_FAIL',
				consumes_resources => 0,
				desc => 'Job terminated due to failure of an allocated node.'},
	'PD'  => {
				name => 'PENDING',
				consumes_resources => 0,
				desc => 'Job is awaiting in the queue for resource allocation. '},
	'PR'  => {
				name => 'PREEMPTED',
				consumes_resources => 0,
				desc => 'Job terminated due to preemption.'},
	'R'   => {
				name => 'RUNNING',
				consumes_resources => 1,
				desc => 'Job is currently crunching data and consumes allocates resources.'},
	'RH'  => {
				name => 'REQUEUE_HOLD',
				consumes_resources => 0,
				desc => 'Job is being held after it was requeued.'},
	'RS'  => {
				name => 'RESIZING',
				consumes_resources => 0,
				desc => 'Job is about to change size.'},
	'SI'  => {
				name => 'SIGNALING',
				consumes_resources => 1,
				desc => 'Job is being signaled.'},
	'SE'  => {
				name => 'SPECIAL_EXIT',
				consumes_resources => 0,
				desc => 'Job was requeued in a special state, which can be set by users if a job terminated with a particular exit value.'},
	'ST'  => {
				name => 'STOPPED',
				consumes_resources => 1,
				desc => 'Job has an allocation, but execution has been stopped with SIGSTOP signal and resources have been retained.'},
	'S'   => {
				name => 'SUSPENDED',
				consumes_resources => 0,
				desc => 'Job had an allocation, but execution has been suspended and resources have been released.'},
	'TO'  => {
				name => 'TIMEOUT',
				consumes_resources => 0,
				desc => 'Job failed, because it exceeded the requested work allocation time (walltime) limit.'},
);

my %known_job_states_long_to_short=(
	'BOOT_FAIL'    => 'BF',
	'CANCELLED'    => 'CA',
	'COMPLETED'    => 'CD',
	'CONFIGURING'  => 'CF',
	'COMPLETING'   => 'CG',
	'DEADLINE'     => 'DL',
	'FAILED'       => 'F',
	'NODE_FAIL'    => 'NF',
	'PENDING'      => 'PD',
	'PREEMPTED'    => 'PR',
	'REQUEUE_HOLD' => 'RH',
	'RESIZING'     => 'RS',
	'RUNNING'      => 'R',
	'SIGNALING'    => 'SI',
	'SPECIAL_EXIT' => 'SE',
	'STOPPED'      => 'ST',
	'SUSPENDED'    => 'S',
	'TIMEOUT'      => 'TO',
);

my $job_states_with_allocated_resources_regex;
foreach my $known_job_state (keys(%known_job_states)) {
	if ($known_job_states{$known_job_state}{'consumes_resources'}) {
		$job_states_with_allocated_resources_regex .= '(' . $known_job_state . ')|';
	}
}
$job_states_with_allocated_resources_regex =~ s/\|$//; # remove last trailing pipe symbol.

#
# Define which characters can be used to show jobs or node state in grid view.
# Characters used to indicate state must not be used as masterletters for jobs.
#
my %state_characters = (
	unknown => '?',
	busy    => '@',
	down    => 'X',
	idle    => '.',
	offline => '0',
	other   => '!'
);
#my $masterletters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
my $masterletters = "ABCDEHIKLNOSTUVYZabcdeiklnopqsuvwxyz-+=<>|/\_~";
my $letters       = $masterletters;
my $underline     = 0;

#
# Coordinates.
#
#             y             x: Offset of where last print statement started on main pad. 
#                              Needs increment before adding additional characters to display.
#             Y             X: Height and width of terminal window. May be smaller than main pad.
#     partial_y     partial_x: Top-left coordinate of the part of the main pad currently displayed in the terminal window.
#        last_y        last_x: Last printed character / bottom right coordinate on main pad.
#          subY          subX: Height and width of sub pad.
# sub_partial_y sub_partial_x: Top-left coordinate of the part of the sub pad currently displayed in the sub pad.
#    sub_last_y    sub_last_x: Last printed character / bottom right coordinate on sub pad.
#
my ($y, $x, $Y, $X, $partial_y, $partial_x, $last_y, $last_x, $sub_Y, $sub_X, $sub_partial_y, $sub_partial_x, $sub_last_y, $sub_last_x) = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

_LoadConfig("/etc/ctoprc");
_LoadConfig("$ENV{HOME}/.ctoprc");

#
# Configure and find commandline utils.
#
-e $squeue   or chomp($squeue   = `which squeue 2>/dev/null`);
-e $sstat    or chomp($sstat    = `which sstat 2>/dev/null`);
-e $scontrol or chomp($scontrol = `which scontrol 2>/dev/null`);
-e $sinfo    or chomp($sinfo    = `which sinfo 2>/dev/null`);
-e $squeue   or die 'FATAL: Cannot find squeue.' .   "\n";
-e $sstat    or die 'FATAL: Cannot find sstat.' .    "\n";
-e $scontrol or die 'FATAL: Cannot find scontrol.' . "\n";
-e $sinfo    or die 'FATAL: Cannot find sinfo.' . "\n";

#
#  Process commandline arguments.
#
my @clusters = ();
while (my $arg = shift @ARGV) {
	if ($arg eq '-u') {
		if (defined $ARGV[0] and $ARGV[0] =~ /^([^-]+)/) {
			$show_user = join(' ', split(',', shift));
		} else {
			_Usage();
			exit(1);
		}
	} elsif ($arg eq '-n') {
		if (defined $ARGV[0] and $ARGV[0] =~ /^([^-]+)/) {
			$show_node = join(' ', split(',', shift));
		} else {
			_Usage();
			exit(1);
		}
	} elsif ($arg eq '-c') {
		if (defined $ARGV[0] and $ARGV[0] =~ /((job)|(user)|(qos)|(resources))/) {
			$color_by = $1;
		} else {
			_Usage();
			exit(1);
		}
	} elsif ($arg eq '-C') {
		$colorize = !$colorize;
	} elsif ($arg eq '-S') {
		$show_summary = !$show_summary;
	} elsif ($arg eq '-G') {
		$show_grid = !$show_grid;
	} elsif ($arg eq '-d') {
		$dense_grid = !$dense_grid;
	} elsif ($arg eq '-Q') {
		$show_queue = !$show_queue;
	} elsif ($arg eq '-t') {
		$show_qqueue = !$show_qqueue;
	} elsif ($arg eq '-j') {
		$show_jobs = !$show_jobs;
	} elsif ($arg eq '-s') {
		$sleeptime = shift @ARGV;
		unless ($sleeptime =~ /^\d+$/ && $sleeptime > 0) {
			_Usage();
			exit(1);
		}
	} elsif ($arg eq '-w') {
		$columns = shift @ARGV;
		unless ($columns =~ /^\d+$/ && $columns > 0) {
			_Usage();
			exit(1);
		}
#	} elsif ($arg =~ /^-(\d+)$/) {
#		@show_cpu = split(//, $1);
	} elsif ($arg =~ /^@(.*)/) {
		push(@clusters, $1);
	} elsif ($arg eq '-V') {
		print "ctop $VERSION\n";
		exit(0);
	} elsif ($arg eq '-h') {
		_Usage();
		exit(0);
	} else {
		_Usage();
		exit(1);
	}
}

#
# If the cluster was not specified,
# try to get it's name from the evironment, defaults or localhost.
#
unless (defined($clusters[0])) {
	if (defined($ENV{"SLURM_CLUSTER_NAME"})) {
		$clusters[0] = $ENV{"SLURM_CLUSTER_NAME"};
	} elsif (`${scontrol} show config | fgrep -i ClusterName` =~ m/ClusterName\s+=\s+([^\s]+)/i) {
		$clusters[0] = $1;
	} else {
		$clusters[0] = `hostname`;
	}
}
chomp(@clusters);

if ($show_job_id eq "all") {
	$show_job_id = 0;
}
if ($show_user eq "all") {
	$show_user = 0;
} elsif ($show_user =~ /\bme\b/) {
	$show_user =~ s/\bme\b/$ENV{USER}/;
}
if ($show_node eq "all") {
	$show_node = 0;
}

use vars qw/$SIGWINCH/;
$SIGWINCH = 0;
$SIG{'WINCH'} = sub { $SIGWINCH = 1; };
$SIG{'INT'}  = sub { endwin; exit(0); };
$SIG{'TERM'} = sub { endwin; exit(0); };

# TODO: Can someone tell me how to use filter() correctly?
-t STDOUT or filter();

#
# TODO: check if definition of control characters like this is portable.
#
my $CTRL_B = chr(ord("B") - ord("@"));
my $CTRL_F = chr(ord("F") - ord("@"));
my $CTRL_L = chr(ord("L") - ord("@"));
my $CTRL_G = chr(ord("G") - ord("@"));
my $CTRL_H = chr(ord("H") - ord("@"));

initscr;
cbreak;
noecho;
getmaxyx($Y, $X);
start_color;
$colorize = $colorize && has_colors();

my $pr = 0;

#
# Every possible color combo is listed below.
# Color pairs that don't look very good are commented out.
# If your eyes disagree with my eyes, you are free to play around with this list.
# Note: only the first $COLOR_PAIRS uncommented combos apply.
# $COLOR_PAIRS is set by your curses implementation.
# The help screen (hit 'h' in ctop) will tell you the value of $COLOR_PAIRS.
#
init_pair(++$pr, COLOR_RED,     COLOR_BLACK);
init_pair(++$pr, COLOR_GREEN,   COLOR_BLACK);
init_pair(++$pr, COLOR_YELLOW,  COLOR_BLACK);
init_pair(++$pr, COLOR_BLUE,    COLOR_BLACK);
init_pair(++$pr, COLOR_MAGENTA, COLOR_BLACK);
init_pair(++$pr, COLOR_CYAN,    COLOR_BLACK);
init_pair(++$pr, COLOR_WHITE,   COLOR_BLACK);

#init_pair( ++$pr, COLOR_BLACK,   COLOR_BLACK );
#init_pair( ++$pr, COLOR_RED,     COLOR_WHITE );
#init_pair( ++$pr, COLOR_GREEN,   COLOR_WHITE );
#init_pair( ++$pr, COLOR_YELLOW,  COLOR_WHITE );
#init_pair( ++$pr, COLOR_BLUE,    COLOR_WHITE );
#init_pair( ++$pr, COLOR_MAGENTA, COLOR_WHITE );
#init_pair( ++$pr, COLOR_CYAN,    COLOR_WHITE );
#init_pair( ++$pr, COLOR_WHITE,   COLOR_WHITE );
init_pair(++$pr, COLOR_BLACK, COLOR_WHITE);

#init_pair( ++$pr, COLOR_RED,     COLOR_YELLOW );
#init_pair( ++$pr, COLOR_GREEN,   COLOR_YELLOW );
#init_pair( ++$pr, COLOR_YELLOW,  COLOR_YELLOW );
#init_pair( ++$pr, COLOR_BLUE,    COLOR_YELLOW );
init_pair(++$pr, COLOR_MAGENTA, COLOR_YELLOW);

#init_pair( ++$pr, COLOR_CYAN,    COLOR_YELLOW );
#init_pair( ++$pr, COLOR_WHITE,   COLOR_YELLOW );
#init_pair( ++$pr, COLOR_BLACK,   COLOR_YELLOW );
init_pair(++$pr, COLOR_RED, COLOR_CYAN);

#init_pair( ++$pr, COLOR_GREEN,   COLOR_CYAN );
init_pair(++$pr, COLOR_YELLOW, COLOR_CYAN);

#init_pair( ++$pr, COLOR_BLUE,    COLOR_CYAN );
init_pair(++$pr, COLOR_MAGENTA, COLOR_CYAN);

#init_pair( ++$pr, COLOR_CYAN,    COLOR_CYAN );
init_pair(++$pr, COLOR_WHITE,  COLOR_CYAN);
init_pair(++$pr, COLOR_BLACK,  COLOR_CYAN);
init_pair(++$pr, COLOR_RED,    COLOR_MAGENTA);
init_pair(++$pr, COLOR_GREEN,  COLOR_MAGENTA);    # current 16th
init_pair(++$pr, COLOR_YELLOW, COLOR_MAGENTA);
init_pair(++$pr, COLOR_BLUE,   COLOR_MAGENTA);

#init_pair( ++$pr, COLOR_MAGENTA, COLOR_MAGENTA );
init_pair(++$pr, COLOR_CYAN,  COLOR_MAGENTA);
init_pair(++$pr, COLOR_WHITE, COLOR_MAGENTA);

#init_pair( ++$pr, COLOR_BLACK,   COLOR_MAGENTA );
#init_pair( ++$pr, COLOR_RED,     COLOR_RED );
init_pair(++$pr, COLOR_GREEN,   COLOR_RED);
init_pair(++$pr, COLOR_YELLOW,  COLOR_RED);
init_pair(++$pr, COLOR_BLUE,    COLOR_RED);
init_pair(++$pr, COLOR_MAGENTA, COLOR_RED);
init_pair(++$pr, COLOR_CYAN,    COLOR_RED);
init_pair(++$pr, COLOR_WHITE,   COLOR_RED);
init_pair(++$pr, COLOR_BLACK,   COLOR_RED);
init_pair(++$pr, COLOR_RED,     COLOR_GREEN);

#init_pair( ++$pr, COLOR_GREEN,   COLOR_GREEN );
#init_pair( ++$pr, COLOR_YELLOW,  COLOR_GREEN );
init_pair(++$pr, COLOR_BLUE, COLOR_GREEN);

#init_pair( ++$pr, COLOR_MAGENTA, COLOR_GREEN );
init_pair(++$pr, COLOR_CYAN,  COLOR_GREEN);
init_pair(++$pr, COLOR_WHITE, COLOR_GREEN);
init_pair(++$pr, COLOR_BLACK, COLOR_GREEN);

my %resource_usage_state_colors = (
	'<' => 3,
	'=' => 2,
	'>' => 1,
	'?' => 1
);

my $pad = newpad($maxrows, $maxcolumns);
my $cmdwin = newwin(1, $X - 1, $Y - 1, 0);
keypad($cmdwin, 1);
my $subpad = 0;
my $subpad_box = 0;
my $subpad_content = 0;
my $helpwin = 0;

_MainLoop(\@clusters);

#   The original color set.
#        "\033[07;34m",    "\033[07;35m",    "\033[07;36m",
#        "\033[07;37m",    "\033[01;37m",    "\033[35m",
#        "\033[36m",       "\033[37m",       "\033[34m",
#        "\033[33m",       "\033[32m",       "\033[01;36;45m",
#        "\033[01;30;47m", "\033[01;30;46m", "\033[36;45m",
#        "\033[30;47m",    "\033[30;46m",    "\033[01;33m",
#        "\033[01;34m",    "\033[01;35m",    "\033[01;36m",
#        "\033[01;31m",    "\033[01;32m",

###############################################################
## All subroutines below here
###############################################################

# _MainLoop() will 
#    1) gather all data for a SLURM cluster, 
#    2) prep it a bit in _Letterize() and _Colorize(), 
#    3) call _UpdateDisplay to draw the grids and job queue and finally 
#    4) call _TopSleep which is where most of the time is spend.

# 1) Gather data by parsing the output of tools like scontrol and squeue.
#    Since this data is kept between cycles around the main loop, we take some care to remove old data.
#    The result is two large structures, one for Jobs and one for Nodes, which are used in the rest of the program.

# 2) _Letterize() and _Colorize() are fairly unexciting,
#    but they do assign letters and colors to each running job.
#    This info is stored in the large Job structure.
#    _Letterize() has probably the only original code left.

# 3) _UpdateDisplay() calls the functions responsible for the summary, colorful grid, and the job listing at the bottom.
#    _PrintGrid() draws a big colorful grid for each core of each node.

# 4) _TopSleep() is a big mess. It is far too monolithic.
#    If anyone wants chop it up a bit, feel free to send patches!
#    It loops around on user input until the time expires and it is time to return back up to _MainLoop().
#    In the meantime, it does everything the user requests,
#    including griding through the main data structures looking for stuff.
#    All of the code responsible for moving around the giant pad is here.

sub _Usage {
	print "Usage:  ctop [options] [\@host ...]\n";
	print "  Version: $VERSION\n";
	print "  Options: \n";
	print "  -u [user] Show only jobs for a subset of users.\n";
	print "            Comma separated list.\n";
	print "  -n [node] Show only jobs for a subset of nodes.\n";
	print "            Comma separated list.\n";
	print "  -c [type] Color cores in grid display by type.\n";
	print "            Type must be one of 'job', 'node', 'qos' or resources.\n";
	print "  -C        Toggle colorization.\n";
	print "  -S        Toggle state summary display.\n";
	print "  -G        Toggle grid display.\n";
	print "  -Q        Toggle queue display.\n";
	print "  -t        Toggle showing queued jobs in queue display.\n";
	#print "  -[0-9]...  cpu numbers for grid display.\n";
	print "  -j        Toggle jobs in grid display.\n";
	print "  -s [0-9]+ Seconds between refreshes.\n";
	print "  -w [0-9]+ With of grid in number of cores to display.\n";
	print "  -V        Print version and exit.\n";
	print "  -h        Print this help and exit.\n";
}

sub _MainLoop {
	my $clusters = shift;
	my %nodes;
	my %jobs;
	my %users;
	my %queues;
	my %state_count;
	my %max_length;
	
	$state_count{'_nodes_total'}     = 0; # Total number of compute nodes.
	$state_count{'_nodes_allocated'} = 0; # Allocated compute nodes where at least one cores is allocated to a job.
	$state_count{'_cores_total'}     = 0; # Total number of CPU cores.
	$state_count{'_cores_allocated'} = 0; # Number of CPU cores allocated to jobs.
	$state_count{'_jobs_running'}    = 0; # Running jobs.
	$state_count{'_jobs_total'}      = 0; # Total number of jobs (both running and queued).
	
	#
	# Set default width of columns to the length of their column labels.
	#
	$max_length{'cluster'} = 7;
	$max_length{'node'}    = 4;
	$max_length{'job_ID'}  = 5;
	$max_length{'user'}    = 4;
	$max_length{'qos'}     = 3;
	
	while (1) {
		
		#
		# Reset state counts.
		#
		foreach my $state (keys(%state_count)) {
			$state_count{$state} = 0;
		}
		
		#_PrintWarning('DEBUG: Running in MainLoop.');
		
		foreach my $cluster (@{$clusters}) {
			#
			# Get updated intel'.
			#
			#_PrintWarning('DEBUG: Retrieving data for cluster ' . $cluster . '.');
			_GetInfo($cluster, \%nodes, \%jobs, \%state_count);
			
			#
			# Remove old nodes that are no longer seen.
			#
			foreach my $node (keys(%{$nodes{$cluster}})) {
				if (!defined($nodes{$cluster}{$node}{'seen'}) or $nodes{$cluster}{$node}{'seen'} == 0) {
					delete($nodes{$cluster}{$node});
				} else {
					$nodes{$cluster}{$node}{'seen'} = 0;
				}
			}
		}
		
		#
		# Remove old jobs that are no longer seen.
		#
		foreach my $job (keys(%jobs)) {
			if (!defined($jobs{$job}{'seen'}) or $jobs{$job}{'seen'} == 0) {
				my $deleted = delete($jobs{$job});
			} else {
				$jobs{$job}{'seen'} = 0;
			}
		}
		
		#
		# Add derived data for jobs and nodes.
		# Assign characters and color pairs to jobs, users and QoS levels.
		#
		_SupplementInfo(\%nodes, \%jobs);
		_Letterize(\%jobs);
		_Colorize(\%jobs, \%users, \%queues);
		
		#
		# Determine max length of certain names, 
		# so we can adjust column widths accordingly.
		#
		$max_length{'cluster'} = 
			    _GetMaxKeyLength(\%nodes) > '7'
			  ? _GetMaxKeyLength(\%nodes)
			  : '7'; # Default == length of column label "cluster" == 7
		
		$max_length{'node'} = 4; # Default == length of column label "node" == 4
		foreach my $cluster (keys(%nodes)) {
			my ($max_node_length_for_this_cluster) = _GetMaxKeyLength($nodes{$cluster});
			$max_length{'node'} = 
			    $max_node_length_for_this_cluster > $max_length{'node'}
			  ? $max_node_length_for_this_cluster
			  : $max_length{'node'};
		}
		#_PrintWarning('DEBUG: max_length for nodes ' . $max_length{'node'} . '.');
		$max_length{'job_ID'} = _GetMaxKeyLength(\%jobs);
		foreach my $job (keys(%jobs)) {
			my ($user_length) = length($jobs{$job}{'user'});
			my ($qos_length)  = length($jobs{$job}{'qos'});
			$max_length{'user'} = 
			    $user_length > $max_length{'user'}
			  ? $user_length
			  : $max_length{'user'};
			$max_length{'qos'} = 
			    $qos_length > $max_length{'qos'}
			  ? $qos_length
			  : $max_length{'qos'};
		}
		
		#
		# Get max length of several values and adjust pad width if necessary.
		#
		my $invariable_width = 23; # for the grid display.
		my $grid_width = (($columns - 1) * 2) + (int($columns / 10) * 2);
		if ($invariable_width + $max_length{'cluster'} + $max_length{'node'} + $grid_width > $maxcolumns) {
			$maxcolumns = $invariable_width + $max_length{'cluster'} + $max_length{'node'} + $grid_width;
			resize($pad, $maxrows, $maxcolumns);
		}
		$invariable_width = 107; # for the queue display.
		if ($invariable_width + $max_length{'job_ID'} + $max_length{'user'} + $max_length{'qos'} > $maxcolumns) {
			$maxcolumns = $invariable_width + $max_length{'job_ID'} + $max_length{'user'} + $max_length{'qos'};
			resize($pad, $maxrows, $maxcolumns);
		}
		
		_UpdateDisplay(\%state_count, \%max_length, \%nodes, \%jobs, \%users, \%queues);
		-t STDOUT or do { endwin; exit; };
		_TopSleep(\%state_count, \%max_length, \%nodes, \%jobs, \%users, \%queues);
	}
}

sub _GetInfo {
	
	my ($cluster, $nodes, $jobs, $state_count) = @_;
	
	#
	# Use SLURM commands to get most of the data for all nodes and all jobs.
	# (For jobs in a state that consumes resources we'll need to run an additional sstat command per job.)
	#
	my $sinfo_format = '%N|%c|%B|%m';
	my @node_info_records = `${sinfo} --clusters ${cluster} --all --noheader -o '${sinfo_format}' -N 2>/dev/null`;
	$? and do { _PrintWarning('Retrieving data using ' . $sinfo . ' failed for cluster ' . $cluster . '.') };
	
	my @node_info_records2 = `${scontrol} --clusters ${cluster} -o show nodes 2>/dev/null`;
	$? and do { _PrintWarning('Retrieving data using ' . $scontrol . ' failed for cluster ' . $cluster . '.') };
	
	my $squeue_format = '%A|%u|%q|%T|%N|%D|%C|%m|%l|%M|%j';
	my @job_info_records = `${squeue} --clusters ${cluster} --all --noheader -o '${squeue_format}' 2>/dev/null`;
	$? and do { _PrintWarning('Retrieving data using ' . $squeue . ' failed for cluster ' . $cluster . '.') };
	
	my $squeue_format2 = 'jobid,tres:';
	my @job_info_records2 = `${squeue} --clusters ${cluster} --all --noheader -O '${squeue_format2}' 2>/dev/null`;
	$? and do { _PrintWarning('Retrieving data using ' . $squeue . ' failed for cluster ' . $cluster . '.') };
	
	#
	# Parse node info.
	#  1. Get some info first from sinfo and delete outdated info.
	#
	foreach my $node_info_record (@node_info_records) {
		
		chomp($node_info_record);
		my @node_info = split(/\|/, $node_info_record);
		next unless(scalar(@node_info) == 4);
		
		my $node        = $node_info[0];
		my $cores_total = $node_info[1];
		my $cores_avail = $node_info[2];
		
		if ($cores_avail eq 'UNLIMITED') {
			$cores_avail = $cores_total;
		}
		
		#
		# Delete outdated info for this node.
		#
		delete ${$nodes}{$cluster}{$node};
		
		#
		# Store new data.
		#
		${$nodes}{$cluster}{$node}{'cores_avail'} = $cores_avail;
		
	}
	
	#
	# Parse job info.
	#
	#  key suffixes in the large jobs data structure:
	#   _r = requested.
	#   _u = used.
	#   _s = state of job efficiency; Determined by used / requested.
	#
	my $sstat_format='JobId,AveCPU,MaxVMSize,MaxRSS,MaxDiskRead,MaxDiskWrite';
	foreach my $job_info_record (@job_info_records) {
		
		chomp($job_info_record);
		next if ($job_info_record =~ m/^CLUSTER:/);
		my @job_info = split(/\|/, $job_info_record);
		
		next unless(scalar(@job_info) == 11);
		
		my $job   = $job_info[0];
		my $state = $job_info[3];
		my $node  = $job_info[4];
		my $cores = $job_info[6];
		if (defined $known_job_states_long_to_short{$state}) {
			$state = $known_job_states_long_to_short{$state};
		} else {
			$state = '?';
		}
		
		${$jobs}{$job}{'seen'}       = 1;
		${$jobs}{$job}{'cluster'}    = $cluster;
		${$jobs}{$job}{'user'}       = $job_info[1];
		${$jobs}{$job}{'qos'}        = $job_info[2];
		${$jobs}{$job}{'state'}      = $state;
		${$jobs}{$job}{'node'}       = $node;
		${$jobs}{$job}{'ncount'}     = $job_info[5]; # node count.
		${$jobs}{$job}{'cores_r'}    = $cores;
		${$jobs}{$job}{'mem_r'}      = _FormatMemInGB($job_info[7], __LINE__);
		${$jobs}{$job}{'walltime_r'} = _FormatTime($job_info[8]);
		${$jobs}{$job}{'walltime_u'} = _FormatTime($job_info[9]);
		${$jobs}{$job}{'jname'}      = $job_info[10];
		#
		# Cannot get usage stats for CPU time nor for Memory from sqeueu; 
		# will need to get that from sstat for running jobs.
		#
		#${$jobs}{$job}{'cputime_u'};
		#${$jobs}{$job}{'mem_u'};
		
		#
		# Update cluster status.
		#
		${$state_count}{'_jobs_total'}++;
		
		#
		# Get additional details for jobs in a state that consumes resources.
		#
		if ($state =~ m/$job_states_with_allocated_resources_regex/) {
			${$state_count}{'_jobs_running'}++;
			#
			# Assign job slots (cores) on a node to this job for display in the Grid.
			#
			${$nodes}{$cluster}{$node}{'jobs'}{$job} = $cores;
			#
			# Get actual resource usage.
			#
			my $job_stat_record = `${sstat} --parsable2 --noheader -o '${sstat_format}' -j ${job}.batch -j ${job} 2>/dev/null`;
			$? and do { _PrintWarning('ERROR: Retrieving data using ' . $sstat . ' failed for job ' . $job . '.') };
			
			#
			# For large clusters it may take a (long) time to fetch and parse the data from the various
			# SLURM commandline tools resulting in outdated data. Currently disabled for our small clusters 
			# as this would create more RPC calls and hence more load while the walltime values 
			# are not that old to create significant bias.
			#
			#my $updated_walltime = `${squeue} --noheader -o '%M' -j ${job} 2>/dev/null`;
			#$? and do { _PrintWarning('ERROR: Retrieving updated walltime using ' . $squeue . ' failed for job ' . $job . '.') };
			#
			#if (defined($updated_walltime) && $updated_walltime ne '') {
			#	chomp($updated_walltime);
			#	${$jobs}{$job}{'walltime_u'} = _FormatTime($updated_walltime);
			#}
			
			chomp($job_stat_record);
			my @job_stats = split(/\|/, $job_stat_record);
			
			if(scalar(@job_stats) == 6) {
				${$jobs}{$job}{'cputime_u'} = _FormatTime($job_stats[1]);
				${$jobs}{$job}{'mem_u'}     = _FormatMemInGB($job_stats[3], __LINE__);
			} else {
				if ($job_stat_record =~ m/there was an error with the request to ([^\s]+) rc . Invalid user id/) {
					my $unpatched_node = $1;
					_PrintWarning('ERROR: ' . $sstat . ' on node ' . $unpatched_node . ' was not patched to allow retrieval of stats for jobs from other users.');
				} elsif ($job_stat_record =~ m/^$/) {
					#
					# Sstat data on resource usage may not be available (yet) when a job started recently on a node: this is normal.
					#_PrintWarning('DEBUG: No ' . $sstat . ' data available for job ' . $job . '.');
					#
				} else {
					_PrintWarning('ERROR: Parsing ' . $sstat . ' data failed for job ' . $job . ' ('. $job_stat_record . ').');
				}
				${$jobs}{$job}{'cputime_u'} = '?';
				${$jobs}{$job}{'mem_u'}     = '?';
			}
		}
	}
	
	#
	# Parse additional node info.
	#  2. Get the remaining and bulk of the info from scontrol.
	#
	foreach my $node_info_record (@node_info_records2) {
		
		chomp($node_info_record);
		#
		# Create pipe separated fields as opposed to space separated ones as the fields may contain spaces too.
		# And assign n/a is a value is missing to prevent the hash mapping below to fail with
		# "Odd number of elements in hash assignment" error.
		#
		$node_info_record =~ s/\s+([^\s]+=)/\|$1/g;
		$node_info_record =~ s/=\|/=N\/A\|/g;
		#
		# Then split fields based on the pipes and create hash entries for the key=value pairs of the fields.
		#
		my %node_info = map {split('=', $_, 2)} (split(/\|/, $node_info_record));
		my $node = $node_info{'NodeName'};
		
		#
		# Store new info for this node.
		#
		${$nodes}{$cluster}{$node}{'seen'}        = 1;
		${$nodes}{$cluster}{$node}{'cores_total'} = $node_info{'CPUTot'};
		${$nodes}{$cluster}{$node}{'state'}       = $node_info{'State'};
		${$nodes}{$cluster}{$node}{'mem_total'}   = $node_info{'RealMemory'};
		${$nodes}{$cluster}{$node}{'features'}    = $node_info{'Features'};
		${$nodes}{$cluster}{$node}{'arch'}        = $node_info{'Arch'};
		
		#
		# Detailed status info like load and assigned resources.
		#
		${$nodes}{$cluster}{$node}{'status'}{'load'}           = $node_info{'CPULoad'};
		${$nodes}{$cluster}{$node}{'status'}{'cores_alloc'}    = $node_info{'CPUAlloc'};
		${$nodes}{$cluster}{$node}{'status'}{'mem_alloc'}      = $node_info{'AllocMem'};
		${$nodes}{$cluster}{$node}{'status'}{'mem_free'}       = $node_info{'FreeMem'};
		${$nodes}{$cluster}{$node}{'status'}{'slurm_version'}  = $node_info{'Version'};
		${$nodes}{$cluster}{$node}{'status'}{'local_tmp_disk'} = $node_info{'TmpDisk'};
		
		#
		# Updated cluster status and total resouces.
		#
		${$state_count}{'_nodes_total'}++;
		${$state_count}{'_cores_total'} += $node_info{'CPUTot'};
		${$state_count}{$node_info{'State'}}++;
		if ($node_info{'CPUAlloc'} > 0) {
			${$state_count}{'_nodes_allocated'}++;
			${$state_count}{'_cores_allocated'} += $node_info{'CPUAlloc'};
		}
		
	}
	
	#
	# Parse additional job info.
	#
	#  key suffixes in the large jobs data structure:
	#   _r = requested.
	#   _u = used.
	#   _s = state of job efficiency; Determined by used / requested.
	#
	# The amount of requested memory in the previously parsed "squeue -o FORMAT" output may be either mem per node or mem per core.
	# As we want to display total mem per job and jobs are restricted to a single node we need mem per node.
	#
	foreach my $job_info_record (@job_info_records2) {
		
		chomp($job_info_record);
		next if ($job_info_record =~ m/^CLUSTER:/);
		my @job_info = split(/\s+/, $job_info_record);
		
		next unless(scalar(@job_info) == 2);
		
		my $job   = $job_info[0];
		my $tres  = $job_info[1];
		
		if ($tres =~ m/mem=([^,]+)/) {
			my $mem_r = $1;
			${$jobs}{$job}{'mem_r'} = _FormatMemInGB($mem_r, __LINE__);
		} else {
			${$jobs}{$job}{'mem_r'} = '?';
			_PrintWarning('ERROR: Cannot parse requested amount of memory from ' . $squeue . ' data for job ' . $job . ' ('. $job_info_record . ').');
		}
	
	}
}

sub _FormatMemInGB {
	
	my ($mem, $caller) = @_;
	my $reformatted_mem_value;
	my $mem_value;
	
	if ($mem =~ m/^([0-9.,]+)([A-Z]+)$/) {
		$mem_value = $1;
		my $mem_unit  = $2;
		if ($mem_unit eq 'B') {
			$mem_value = $mem_value / 1073741824;
		} elsif ($mem_unit eq 'K') {
			$mem_value = $mem_value / 1048576;
		} elsif ($mem_unit eq 'M') {
			$mem_value = $mem_value / 1024;
		} elsif ($mem_unit eq 'G') {
			$mem_value = $mem_value;
		} elsif ($mem_unit eq 'T') {
			$mem_value = $mem_value * 1024;
		} else {
			die "FATAL: Unsupported unit $mem_unit in memory value $mem called by line $caller.";
		}
	} elsif ($mem =~ m/^([0-9.,]+)$/) {
		$mem_value = $1 / 1073741824;
	} else {
		die "FATAL: Unsupported memory value: $mem.";
	}
	$reformatted_mem_value = sprintf("%.1f", $mem_value);
	
	return($reformatted_mem_value);
}

sub _FormatTime {
	
	my ($time) = @_;
	my $reformatted_time;
	my $days;
	my $hours;
	my $minutes;
	my $seconds;
	
	#
	# Drop resolution by removing fractions of a second.
	#  e.g. 2-04:14:38.024 -> 2-04:14:38.
	#
	$time =~ s/\.[0-9]+$//;
	
	if ($time =~ m/^([0-9]+)-([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})$/) {
		$days    = $1;
		$hours   = $2;
		$minutes = $3;
		$seconds = $4;
	} elsif ($time =~ m/^([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})$/) {
		$days    = '0';
		$hours   = $1;
		$minutes = $2;
		$seconds = $3;
	} elsif ($time =~ m/^([0-9]{1,2}):([0-9]{1,2})$/) {
		$days    = '0';
		$hours   = '0';
		$minutes = $1;
		$seconds = $2;
	} elsif ($time eq 'INVALID') {
		#
		# "INVALID" is usually the result of time synchronisation issues: check your NTP configs. 
		# When the clocks are only a little bit off, 
		# INVALID pops up just after a job started running on a node and will vanish later on...
		# The larger the descrpency in time between machines, the longer it will take before you get 
		# something that resembles a timestamp... but is actually wrong.
		#
		$days    = '0';
		$hours   = '0';
		$minutes = '0';
		$seconds = '0';
		_PrintWarning('ERROR: invalid timestamp. Check NTP configs of alle machines in your cluster.');
	} else {
		die "FATAL: Unsupported time value: $time.";
	}
	$reformatted_time = sprintf('%u-%02u:%02u:%02u', $days, $hours, $minutes, $seconds);
	
	return($reformatted_time);
}


sub _SupplementInfo {
	
	my ($nodes, $jobs) = @_;
	
	#
	# Revisit info about all jobs and 
	#  * add defaults for required data if missing.
	#  * calculate derived data.
	#
	foreach my $job (keys(%{$jobs})) {
		foreach my $attribute ('cluster','jname','user','qos','state') {
			unless (defined(${$jobs}{$job}{$attribute})) {
				${$jobs}{$job}{$attribute} = '?';
				_PrintWarning('ERROR: Missing required attribute ' . $attribute . ' for job ' . $job);
			}
		}
		if (defined(${$jobs}{$job}{'cputime_u'}) && defined(${$jobs}{$job}{'walltime_u'})) {
			my $cputime_u = ${$jobs}{$job}{'cputime_u'};
			if ($cputime_u eq '?') {
				${$jobs}{$job}{'cpu_u'} = '?';
			} else {
				my @cputime = reverse(split(/:|-/, ${$jobs}{$job}{'cputime_u'}));
				my $cputime_sec = $cputime[0] + ($cputime[1] * 60) + ($cputime[2] * 3600) + ($cputime[3] * 86400);
				my @walltime = reverse(split(/:|-/, ${$jobs}{$job}{'walltime_u'}));
				my $walltime_sec = $walltime[0] + ($walltime[1] * 60) + ($walltime[2] * 3600) + ($walltime[3] * 86400);
				if ($walltime_sec > 0) {
					${$jobs}{$job}{'cpu_u'} = sprintf("%u", ($cputime_sec / $walltime_sec) * 100);
				}
				#_PrintWarning("DEBUG: walltime_sec = $walltime[0] | $walltime[1] | $walltime[2]");
				#_PrintWarning("DEBUG: cputime = ${$jobs}{$job}{cputime_u} | walltime = ${$jobs}{$job}{walltime_u} | cputime_sec = $cputime_sec | walltime_sec = $walltime_sec");
			}
		}
		if (defined(${$jobs}{$job}{'cores_r'}) && ${$jobs}{$job}{'cores_r'} > 0) {
			${$jobs}{$job}{'cpu_r'} = ${$jobs}{$job}{'cores_r'} * 100;
		} else {
			${$jobs}{$job}{'cpu_r'} = undef;
		}
		if (defined(${$jobs}{$job}{'cpu_u'} && defined(${$jobs}{$job}{'cpu_r'}))) {
			my $cpu_u = ${$jobs}{$job}{'cpu_u'};
			my $cpu_r = ${$jobs}{$job}{'cpu_r'};
			my $cpu_s; # usage state.
			if ($cpu_u eq '?' || $cpu_r eq '?') {
				${$jobs}{$job}{'cpu_s'} = '?';
			} else {
				if (($cpu_u / $cpu_r) < $res_usage_low) {
					$cpu_s = '<';
				} elsif (($cpu_u / $cpu_r) > $res_usage_high) {
					$cpu_s = '>';
				} else {
					$cpu_s = '=';
				}
				${$jobs}{$job}{'cpu_s'} = $cpu_s;
			}
		}
		if (defined(${$jobs}{$job}{'pmem_r'})) {
			if (defined(${$jobs}{$job}{'cores_r'})) {
				my $total_mem = sprintf("%.1f", ${$jobs}{$job}{'pmem_r'} * ${$jobs}{$job}{'cores_r'});
				if (defined(${$jobs}{$job}{'mem_r'})) {
					if (${$jobs}{$job}{'mem_r'} < $total_mem) {
						${$jobs}{$job}{'mem_r'} = $total_mem;
					}
				} else {
					${$jobs}{$job}{'mem_r'} = $total_mem;
				}
			}
		}
		if (!defined(${$jobs}{$job}{'mem_r'}) || (${$jobs}{$job}{'mem_r'} ne '?' && ${$jobs}{$job}{'mem_r'} <= 0)) {
			${$jobs}{$job}{'mem_r'} = 0.1 # default to low value if not specified to prevent illegal devide by zero errors.
		}
		if (defined(${$jobs}{$job}{'mem_u'}) && defined(${$jobs}{$job}{'mem_r'})) {
			my $mem_u = ${$jobs}{$job}{'mem_u'};
			my $mem_r = ${$jobs}{$job}{'mem_r'};
			my $mem_s; # usage state.
			if ($mem_u eq '?' || $mem_r eq '?') {
				${$jobs}{$job}{'mem_s'} = '?';
			} else {
				if (($mem_u / $mem_r) < $res_usage_low) {
					$mem_s = '<';
				} elsif (($mem_u / $mem_r) > $res_usage_high) {
					$mem_s = '>';
				} else {
					$mem_s = '=';
				}
				${$jobs}{$job}{'mem_s'} = $mem_s;
			}
		}
	}
}

sub _UpdateDisplay {
	
	my ($state_count, $max_length, $nodes, $jobs, $users, $queues) = @_;
	
	my $foo;
	move($pad, 0, 0);
	getmaxyx($Y, $X);
	$y = 0, $x = 0;
	
	$show_summary and _PrintStateSummary($state_count);
	$show_grid    and _PrintGrid($jobs, $nodes, $users, $queues, $max_length);
	$show_queue   and _PrintQueue($jobs, $users, $queues, $max_length);
	
	getyx($pad, $last_y, $foo);
	clrtobot($pad);
	
	pnoutrefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
	mvwin($cmdwin, $Y - 1, 0);
	refresh($cmdwin);
	_UpdateSubWindow(@_);
}

#
# Print summary state of entire cluster.
#
sub _PrintStateSummary {
	
	my ($state_count) = @_;
	
	#
	# Usage summary.
	#
	addstr($pad, sprintf("Usage Totals: %d/%d %s | %d/%d %s | %d/%d %s", 
		${$state_count}{'_cores_allocated'}, ${$state_count}{'_cores_total'}, 'Cores', 
		${$state_count}{'_nodes_allocated'}, ${$state_count}{'_nodes_total'}, 'Nodes', 
		${$state_count}{'_jobs_running'},    ${$state_count}{'_jobs_total'}, 'Jobs Running'));
	
	#
	# Show time stamp.
	#
	my ($y1, $x1);
	getyx($pad, $y1, $x1);
	my $max_state_line_length = $X < $maxcolumns ? $X : $maxcolumns;
	addstr($pad, ' ' . ' ' x ($max_state_line_length - $x1 - 23));
	#_PrintWarning("DEBUG: X = $X | Y = $Y | x1 = $x1 | y1 = $y1 | current x = $x | current y = $y");
	#addstr($pad, sprintf("%02d:%02d:%02d", (localtime())[ 2, 1, 0 ]));
	addstr($pad, `date "+%Y-%m-%d-T%H:%M:%S"`);
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
	
	#
	# Show node summary.
	#
	my $line;
	my @states = sort(grep(!/^_/, keys(%{$state_count})));
	addstr($pad, 1, 0, 'Node States:');
	for (my $i = 0 ; defined($states[$i]) ; $i++) {
		$line = ' ' . ${$state_count}{$states[$i]} . ' ' . $states[$i];
		$line .= defined($states[$i + 1]) ? ' |' : '';
		getyx($pad, $y1, $x1);
		if ($X - $x1 - 1 < length($line)) {
			clrtoeol($pad);
			move($pad, ++$y, $x = 0);
			addstr($pad, ' ' x 12);
		}
		addstr($pad, $line);
	}
	move($pad, ++$y, $x = 0);
	clrtoeol($pad);
}

sub _PrintGrid {
	
	my ($jobs, $nodes, $users, $queues, $max_length) = @_;
	
	$last_x = 0;
	
	#
	# Keep track of columns.
	#  * Column 0 contains the node name.
	#  * Column 1 - ... contains the cores / job slots on that node.
	#
	my $col = 0;
	my $headerspaces = 1;
	
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
	
	if (!scalar @show_cpu) {
		#addstr($pad, "  No CPUs selected!");
		#clrtoeol($pad);
		#return;
		$show_cpu[0] = "0";
	}
	
	#_PrintVcpuLine($max_length);
	
	foreach my $cluster (sort(keys(%{$nodes}))) {
		
		_PrintNumberLine($max_length, $headerspaces, $columns);
		$dense_grid and _PrintDashLine($max_length, $headerspaces, $columns);
		
		foreach my $node (sort(keys(%{${$nodes}{$cluster}}))) {
			
			unless ($show_node ? $show_node =~ /\b$node\b/ : 1) {
				next;
			}
			
			$dense_grid or _PrintDashLine($max_length, $headerspaces, $columns);
			
			my $col = 0;
			my $load =
			  defined(${$nodes}{$cluster}{$node}{status}{'load'})
			  ? ${$nodes}{$cluster}{$node}{status}{'load'}
			  : '?';
			my $node_state  = ${$nodes}{$cluster}{$node}{'state'};
			my $total_cores = ${$nodes}{$cluster}{$node}{'cores_total'};
			my $avail_cores = ${$nodes}{$cluster}{$node}{'cores_avail'};
			my $used_cores  = ${$nodes}{$cluster}{$node}{'status'}{'cores_alloc'};
			my $used_mem    = ${$nodes}{$cluster}{$node}{'status'}{'mem_alloc'};
			my $listed_cores = 0;
			
			#
			# Grid display sorted by job.
			#
			JOB: foreach my $job (sort(keys(%{${$nodes}{$cluster}{$node}{'jobs'}}))) {
				
				my $letter    = 0;
				my $color     = 0;
				my $underline = 0;
				my $cpu_state = 'ALLOC';
				
				#
				# Sanity checks on presense of data.
				#
				unless (defined(${$jobs}{$job})) {
					_PrintWarning('WARN: Job ' . $job . ' was seen running on a node, but is missing in job list. (May be sync issue.)');
					next JOB;
				}
				unless (    defined(${$jobs}{$job}{'user'})
						and defined(${$jobs}{$job}{'node'})) {
					_PrintWarning('WARN: Job ' . $job . ' was seen running on a node, but is lacking user or node info in the job list.');
					next JOB;
				}
				
				#
				# Check if we need to display or skip this job.
				#
				unless (    ($show_user     ? $show_user     =~ /\b$$jobs{$job}{user}\b/ : 1)
						and ($show_node     ? $show_node     =~ /\b$$jobs{$job}{node}\b/ : 1)
						and ($show_job_id   ? $show_job_id   =~ m/\b$job\b/ : 1)
					   ) {
					next JOB;
				}
					
				#
				# Get job details.
				# By default color by job.
				#
				unless (    defined(${$jobs}{$job}{'letter'})
						and defined(${$jobs}{$job}{'color'})
						and defined(${$jobs}{$job}{'underline'})
						and defined(${$jobs}{$job}{'qos'})) {
					_PrintWarning('WARN: Job ' . $job . ' was seen running on a node, but is lacking details (letter, color, underline or qos).');
				}
				$letter    = ${$jobs}{$job}{'letter'};
				$color     = ${$jobs}{$job}{'color'};
				$underline = ${$jobs}{$job}{'underline'};
				my $user   = ${$jobs}{$job}{'user'};
				my $qos    = ${$jobs}{$job}{'qos'};
				
				if ($color_by eq 'user') {
					$color = ${$users}{$user}{'color'};
				} elsif ($color_by eq 'qos') {
					$color = ${$queues}{$qos}{'color'};
				} elsif ($color_by eq 'resources') {
					$color = 7; # white on black.
					if (defined(${$jobs}{$job}{'cpu_s'}) && defined(${$jobs}{$job}{'mem_s'})) {
						my $cpu_s = ${$jobs}{$job}{'cpu_s'};
						my $mem_s = ${$jobs}{$job}{'mem_s'};
						if ($cpu_s eq '=' && $mem_s eq '=') {
							$color = $resource_usage_state_colors{'='};
						} else {
							if ($cpu_s eq '<' || $mem_s eq '<') {
								$color = $resource_usage_state_colors{'<'};
							}
							if ($cpu_s eq '>' || $mem_s eq '>') {
								$color = $resource_usage_state_colors{'>'};
							}
						}
					}
				}
				
				for (my $slots = 1 ; $slots <= ${$nodes}{$cluster}{$node}{'jobs'}{$job} ; $slots++) {
					if ($col >= $columns) {
						move($pad, ++$y, $x = 0);
						$col = 0;
					}
					if ($col == 0) {
						addstr($pad, sprintf "  %${$max_length}{'cluster'}s %${$max_length}{'node'}s ", $cluster, $node);
					} elsif ($col != 0 and $col % 10 == 0) {
						addstr($pad, '  ');
					}
					_PrintCoreState($job, $letter, $cpu_state, $color, $underline);
					addstr($pad, ' ');
					clrtoeol($pad);
					$col++;
					$listed_cores++;
				}
			}
			
			#
			# When not all cores are used: fill the remaining ones in the grid with the node state.
			#
			my $core_state   = $node_state;
			while ($listed_cores < $total_cores) {
				if ($col >= $columns) {
					move($pad, ++$y, $x = 0);
					$col = 0;
				}
				if ($col == 0) {
					addstr($pad, sprintf "  %${$max_length}{'cluster'}s %${$max_length}{'node'}s ", $cluster, $node);
				} elsif ($col != 0 and $col % 10 == 0) {
					addstr($pad, '  ');
				}
				if ($listed_cores >= $avail_cores && ($node_state eq 'IDLE' || $node_state eq 'MIXED')) {
					$core_state = 'RESERVED';
				}
				_PrintCoreState(0, 0, $core_state, 0, 0);
				addstr($pad, ' ');
				$col++;
				clrtoeol($pad);
				$listed_cores++;
			}
			
			while ($col < $columns) {
				addstr($pad, '  ') if ($col != 0 and $col % 10 == 0);
				addstr($pad, '  ');
				$col++;
				clrtoeol($pad);
			}
			
			#
			# Print node load and health.
			# Health will warn if the load is inefficiently low or dangerously high.
			#
			addstr($pad, sprintf "%6s ", $load);
			my $health = '= ? ';
			my $color = 3;
			if ($load =~ m/^(\d*\.)?\d+$/) {
				if ($load < $used_cores - $healthy_load_stdev) {
					$health = '= too low!';
					$color  = 3;
				} elsif ($load > $used_cores + $healthy_load_stdev) {
					$health = '= TOO HIGH!';
					$color = 1;
				} else {
					$health = '= Ok';
					$color = 2;
				}
			}
			$colorize and attron($pad, A_BOLD | COLOR_PAIR($color));
			addstr($pad, $health);
			$colorize and attroff($pad, A_BOLD | COLOR_PAIR($color));
			getyx($pad, my $current_last_y, my $current_last_x);
			$last_x = $last_x > $current_last_x ? $last_x : $current_last_x;
			clrtoeol($pad);
			move($pad, ++$y, $x = 0);
			
			clrtoeol($pad);
			move($pad, ++$y, $x = 0) if $col != $columns;
		}
		
		_PrintDashLine($max_length, 1, $columns);
		
	}
	
	#
	# Print legend underneath grid.
	#
	my $legend = sprintf("  %${$max_length}{'cluster'}s %${$max_length}{'node'}s ", ' ', ' ');
	$legend .= 'legend:';
	$legend .= " $state_characters{'unknown'} unknown";
	$legend .= " | $state_characters{'busy'} busy";
	$legend .= " | $state_characters{'down'} down";
	$legend .= " | $state_characters{'idle'} idle";
	$legend .= " | $state_characters{'offline'} offline";
	$legend .= " | $state_characters{'other'} other";
	addstr($pad, $y, 0, $legend);
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
	clrtoeol($pad);
	
}

#
# Print the job queue.
#
sub _PrintQueue {
	
	my ($jobs, $users, $queues, $max_length) = @_;
	
	#
	# Get max length of several values and adjust pad width if necessary.
	#
	my $max_job_id_length = ${$max_length}{'job_ID'};
	my $max_user_length   = ${$max_length}{'user'};
	my $max_qos_length    = ${$max_length}{'qos'};
	
	my $format_base     = "%-${max_job_id_length}s %-${max_user_length}s %-${max_qos_length}s %-40.40s %-2.2s";
	my $format_cpu      = " %6.6s";
	my $format_mem      = " %8.8s";
	my $format_walltime = " %10.10s";
	
	move($pad, ++$y, $x = 0);
	attron($pad, A_BOLD);
	addstr($pad, '      ');
	addstr($pad, sprintf($format_base, 'JobID', 'Username', 'QoS', 'Jobname', 'S'));
	addstr($pad, sprintf($format_cpu, 'CPU(%)'));
	addstr($pad, sprintf($format_cpu, 'CPU(%)'));
	addstr($pad, sprintf($format_mem, 'Mem(GiB)'));
	addstr($pad, sprintf($format_mem, 'Mem(GiB)'));
	addstr($pad, sprintf($format_walltime, 'Walltime'));
	addstr($pad, sprintf($format_walltime, 'Walltime'));
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
	addstr($pad, '      ');
	addstr($pad, sprintf($format_base, '', '', '', '', ''));
	addstr($pad, sprintf($format_cpu, '~used'));
	addstr($pad, sprintf($format_cpu, 'req.'));
	addstr($pad, sprintf($format_mem, 'used'));
	addstr($pad, sprintf($format_mem, 'req.'));
	addstr($pad, sprintf($format_walltime, 'used'));
	addstr($pad, sprintf($format_walltime, 'requested'));
	attroff($pad, A_BOLD);
	clrtoeol($pad);
	getyx($pad, my $current_last_y, my $current_last_x);
	$last_x = $last_x > $current_last_x ? $last_x : $current_last_x;
	move($pad, ++$y, $x = 0);
	
	#
	# Note: we never print the cluster name as we expected users will recognize their jobs by jobID or QoS name.
	#
	
	#
	# Print jobs sorted by
	#  1. cluster followed by
	#  2. JobID without optional array task suffix followed by
	#  3. opional array task suffix.
	#
	foreach my $job (sort{     (defined(${$jobs}{$a}{'cluster'}) && defined(${$jobs}{$b}{'cluster'}) && ${$jobs}{$a}{'cluster'} cmp ${$jobs}{$b}{'cluster'})
							or (($a =~ m/^(\d+)/)[0] <=> ($b =~ m/^(\d+)/)[0])
							or ($a =~ m/\[(\d+)\]$/ && $b =~ m/\[(\d+)\]$/ && ($a =~ m/\[(\d+)\]$/)[0] <=> ($b =~ m/\[(\d+)\]$/)[0])
						} keys(%{$jobs})) {
		
		if ($y >= $maxrows ) {
			_PrintWarning('WARN: too many jobs -> queue display truncated. Increase $maxrows or use one of the filter commands.');
			return;
		}
		
		#
		# Get job details required to determine if this job will be displayed or skipped.
		#
		my $user  = ${$jobs}{$job}{'user'};
		my $qos   = ${$jobs}{$job}{'qos'};
		my $state = ${$jobs}{$job}{'state'};
		my $node  = defined(${$jobs}{$job}{'node'}) ? ${$jobs}{$job}{'node'}  : '-';
		
		#
		# Skip this job if display was not requested.
		#
		next unless ($show_job_id   ? $show_job_id   =~ m/\b$job\b/ : 1);
		next unless ($show_user     ? $show_user     =~ m/\b$user\b/ : 1);
		
		next unless ($state =~ m/$job_states_with_allocated_resources_regex/ && $show_node ? $show_node =~ /\b$node\b/ : 1);
		next if ($state !~ m/$job_states_with_allocated_resources_regex/ && $show_qqueue == 0);
		
		#
		# Get job details that determine how the job will be displayed. 
		#
		my $job_name  = ${$jobs}{$job}{'jname'};
		my $l         = ${$jobs}{$job}{'letter'};
		my $underline = ${$jobs}{$job}{'underline'};
		my $color     = ${$jobs}{$job}{'color'};
		if ($color_by eq 'user') {
			$color = ${$users}{$user}{'color'};
		} elsif ($color_by eq 'qos') {
			$color = ${$queues}{$qos}{'color'};
		} elsif ($color_by eq 'resources') {
			$color = 7; # white on black.
			if (defined(${$jobs}{$job}{'cpu_s'}) && defined(${$jobs}{$job}{'mem_s'})) {
				my $cpu_s = ${$jobs}{$job}{'cpu_s'};
				my $mem_s = ${$jobs}{$job}{'mem_s'};
				if ($cpu_s eq '=' && $mem_s eq '=') {
					$color = $resource_usage_state_colors{'='};
				} else {
					if ($cpu_s eq '<' || $mem_s eq '<') {
						$color = $resource_usage_state_colors{'<'};
					}
					if ($cpu_s eq '>' || $mem_s eq '>') {
						$color = $resource_usage_state_colors{'>'};
					}
				}
			}
		}
		
		addstr($pad, '  ');
		if (defined($l) and $state =~ m/$job_states_with_allocated_resources_regex/) {
			_PrintColoredLetter($l, $color, $underline);
			addstr($pad, ' = ');
		} else {
			addstr($pad, '    ');
		}
		
		#
		# Print base job info.
		#
		addstr($pad, sprintf($format_base, 
			$job, 
			${$jobs}{$job}{'user'}, 
			${$jobs}{$job}{'qos'}, 
			${$jobs}{$job}{'jname'}, 
			${$jobs}{$job}{'state'}
		));
		#_PrintWarning('DEBUG: Job ' . $job .' | user '. ${$jobs}{$job}{'user'} . ' | qos ' . ${$jobs}{$job}{'qos'} . ' | state ' . ${$jobs}{$job}{'state'} . '.');
		
		#
		# Print job's CPU info.
		#
		if (defined(${$jobs}{$job}{'cpu_u'})) {
			my $cpu_u = ${$jobs}{$job}{'cpu_u'};
			if ($colorize && defined(${$jobs}{$job}{'cpu_s'})) {
				my $state = ${$jobs}{$job}{'cpu_s'};
				attron($pad, A_BOLD | COLOR_PAIR($resource_usage_state_colors{$state}));
				addstr($pad, sprintf($format_cpu, $cpu_u));
				attroff($pad, A_BOLD | COLOR_PAIR($resource_usage_state_colors{$state}));
			} else {
				addstr($pad, sprintf($format_cpu, $cpu_u));
			}
		} else {
			addstr($pad, sprintf($format_cpu, ''));
		}
		addstr($pad, sprintf($format_cpu, 
			defined(${$jobs}{$job}{'cpu_r'}) ? ${$jobs}{$job}{'cpu_r'} : ''
		));
		
		#
		# Print job's memory info.
		#
		if (defined(${$jobs}{$job}{'mem_u'})) {
			my $mem_u = ${$jobs}{$job}{'mem_u'};
			if ($colorize && defined(${$jobs}{$job}{'mem_s'})) {
				my $state = ${$jobs}{$job}{'mem_s'};
				attron($pad, A_BOLD | COLOR_PAIR($resource_usage_state_colors{$state}));
				addstr($pad, sprintf($format_mem, $mem_u));
				attroff($pad, A_BOLD | COLOR_PAIR($resource_usage_state_colors{$state}));
			} else {
				addstr($pad, sprintf($format_mem, $mem_u));
			}
		} else {
			addstr($pad, sprintf($format_mem, ''));
		}
		addstr($pad, sprintf($format_mem, 
			defined(${$jobs}{$job}{'mem_r'}) ? ${$jobs}{$job}{'mem_r'} : ''
		));
		
		#
		# Print job's walltime info.
		#
		addstr($pad, sprintf($format_walltime, 
			defined(${$jobs}{$job}{'walltime_u'}) ? ${$jobs}{$job}{'walltime_u'} : ''
		));
		addstr($pad, sprintf($format_walltime, 
			defined(${$jobs}{$job}{'walltime_r'}) ? ${$jobs}{$job}{'walltime_r'} : ''
		));
		
		clrtoeol($pad);
		move($pad, ++$y, $x = 0);
		
	}
	
	clrtoeol($pad);
}

#
# Assign a letter to each job.
#
sub _Letterize {
	
	my ($jobs) = @_;
	
	#
	# %job_of_letter is only used to note the fact that _someone_ is using that letter.
	# If a job gets a letter that is already assigned, 
	# the second one will be noted in %job_of_letter,
	# which is Ok because we don't care _who_ has that letter.
	
	#
	# Remove info about old jobs.
	#
	foreach my $l (keys(%job_of_letter)) {
		my $job_id_of_l = $job_of_letter{$l};
		unless (defined(${$jobs}{$job_id_of_l})) {
			my $deleted = delete($job_of_letter{$l});
		}
	}
	
	#
	# Pick a letter.
	#
	foreach my $job (keys(%{$jobs})) {
		#
		# Skip jobs that already have a letter assigned
		# or that are queued / on hold and do not yet need a letter.
		#
		next unless (defined(${$jobs}{$job}{'state'}));
		next if (${$jobs}{$job}{'state'} !~ m/$job_states_with_allocated_resources_regex/);
		my $user = ${$jobs}{$job}{'user'};
		unless (defined(${$jobs}{$job}{'letter'})) {
			#
			# Find a letter that isn't already taken.
			#
			my $l = substr($user, 0, 1);
			if (defined($job_of_letter{$l})) {
				$l = uc($l);
				if (defined($job_of_letter{$l})) {
					if (length($letters) <= 0) {
						#
						# Replenish our supply of letters.
						#
						$colorize or _PrintWarning('WARN: Reusing letters on B&W terminal.');
						$letters   = $masterletters;
						$underline = !$underline;
					}
					$letters =~ s/(.)//;
					$l = $1;
				}
			}
			$job_of_letter{$l}          = $job;
			${$jobs}{$job}{'letter'}    = $l;
			${$jobs}{$job}{'underline'} = $underline;
			if ($l =~ m/[^a-zA-Z0-9_]/) {
				$l = '\\' . "$l";
			}
			$letters =~ s/$l//;
		}
	}
}

#
# Assign a color to each job, user and QoS.
#
sub _Colorize {
	
	my ($jobs, $users, $queues) = @_;
	
	foreach my $job (keys(%{$jobs})) {
		next if (defined(${$jobs}{$job}{'color'}));
		
		scalar(@colors == 0) and @colors = _InitColors();
		my $color = shift(@colors);
		${$jobs}{$job}{'color'} = $color;
		
		my $user  = ${$jobs}{$job}{'user'};
		my $qos   = ${$jobs}{$job}{'qos'};
		${$users}{$user}{'color'} = $color unless (defined(${$users}{$user}{'color'}));
		${$queues}{$qos}{'color'} = $color unless (defined(${$queues}{$qos}{'color'}));
	}
}

sub _InitColors {
	return (1 .. ($COLOR_PAIRS - 1 > $pr ? $pr : $COLOR_PAIRS - 1));
}

# This sucks, I wanted to seperate printing from colors,
# but I can't just pass back color escape strings.
# I'm forced to combine them here.
sub _PrintColoredLetter {
	my ($letter, $color, $underline) = @_;
	if ($colorize) {
		#_PrintWarning("DEBUG: color = $color");
		attron($pad, A_BOLD | COLOR_PAIR($color) | ($underline && A_UNDERLINE));
		addstr($pad, $letter);
		attroff($pad, A_BOLD | COLOR_PAIR($color) | ($underline && A_UNDERLINE));
	} else {
		addstr($pad, $letter);
	}
}

#
# Used to find the longest hostnames to align the left side of the grid.
#
sub _GetMaxKeyLength {
	my ($hash) = @_;
	my $max_length = 0;
	foreach my $value (keys(%{$hash})) {
		$max_length =
		    length($value) > $max_length
		  ? length($value)
		  : $max_length;
	}
	return($max_length);
}

#
# Prints each character representing each core in the grid.
#
sub _PrintCoreState {
	
	my ($job, $letter, $state, $color, $underline) = @_;
	
	if ($job) {
		unless ($letter) {
			_PrintWarning("WARN: $job has no letter.");
			$letter = $state_characters{'unknown'};
		}
	}
	
	if ($state =~ /down/ and $job) {
		_PrintColoredLetter($letter, $color, $underline);
	} elsif ($job and $show_jobs) {
		_PrintColoredLetter($letter, $color, $underline);
	} elsif ($state =~ /[\*]$/) {
		addch($pad, $state_characters{'down'});
	} elsif ($state =~ /[\#\$]$/) {
		addch($pad, $state_characters{'offline'});
	} elsif ($state =~ /NoResp/i) {
		addch($pad, $state_characters{'offline'});
	} elsif ($state =~ /ALLOC/i) {
		addch($pad, $state_characters{'busy'});
	} elsif ($state =~ /COMP/i) {
		addch($pad, $state_characters{'busy'});
	} elsif ($state =~ /DOWN/i) {
		addch($pad, $state_characters{'down'});
	} elsif ($state =~ /DRAIN/i) {
		addch($pad, $state_characters{'offline'});
	} elsif ($state =~ /ERROR/i) {
		addch($pad, $state_characters{'offline'});
	} elsif ($state =~ /FAIL/i) {
		addch($pad, $state_characters{'offline'});
	} elsif ($state =~ /FUTURE/i) {
		addch($pad, $state_characters{'offline'});
	} elsif ($state =~ /IDLE/i) {
		addch($pad, $state_characters{'idle'});
	} elsif ($state =~ /MAINT/i) {
		addch($pad, $state_characters{'offline'});
	} elsif ($state =~ /MIXED/i) {
		addch($pad, $state_characters{'idle'});
	} elsif ($state =~ /PERF/i) {
		addch($pad, $state_characters{'busy'});
	} elsif ($state =~ /NPC/i) {
		addch($pad, $state_characters{'busy'});
	} elsif ($state =~ /RESERVED/i) {
		addch($pad, $state_characters{'busy'});
	} elsif ($state =~ /POWER/i) {
		addch($pad, $state_characters{'down'});
	} elsif ($state =~ /RESUME/i) {
		addch($pad, $state_characters{'busy'});
	} elsif ($state =~ /UNK/i) {
		addch($pad, $state_characters{'unknown'});
	} else {
		addch($pad, $state_characters{'other'});
		_PrintWarning("WARN: unknown node state $state.");
	}
}

#
# Print the list of visible CPUs above the grid.
#
sub _PrintVcpuLine {
	
	my ($max_length) = @_;
	
	# inform the user of the visible CPUs.
	if (scalar(@show_cpu) == 1) {
		addstr($pad, "  CPU $show_cpu[0]" . ' ' x (${$max_length}{'cluster'} + 1 + ${$max_length}{'node'} - 4));
	#} elsif ( scalar @show_cpu == $maxprocs ) {
	#	addstr($pad, '   ' . ' ' x ($maxlen));
	} else {
		addstr($pad, ' ' x ($X - 1));
		move($pad, $y, 0);
		addstr($pad, ' visible CPUs: ' . join(',', @show_cpu));
	}
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
}

#
# Print the line of dashes above and below a node in the grid.
#
sub _PrintDashLine {
	
	my ($max_length, $spaces, $columns) = @_;
	
	my $line = '   ' . ' ' x (${$max_length}{'cluster'} + 1 + ${$max_length}{'node'});
	for (my $i = 0 ; $i < $columns ; $i++) {
		$line .= '--' if ($i != 0 and $i % 10 == 0);
		$line .= '-' . '-' x $spaces;
	}
	$line =~ s/-$//; # Create one dash too much; delete it.
	addstr($pad, $line);
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
}

#
# Print the line of sequential numbers for the cores along the top of the grid.
#
sub _PrintNumberLine {
	
	my ($max_length, $spaces, $columns) = @_;
	
	my $line = '  ' . sprintf("%${$max_length}{'cluster'}s", 'cluster') . ' ' . sprintf("%${$max_length}{'node'}s", 'node') . ' ';
	for (my $i = 0, my $j = 0 ; $i < $columns ; $i++, $j++) {
		if ($i != 0 and $i % 10 == 0) {
			$line .= '  ';
			$j = 0;
		}
		$line .= (($j + 1) % 10) . ' ' x $spaces;
	}
	addstr($pad, $line);
	addstr($pad, sprintf "%6s ", 'load');
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
	
}

#
# This is used in _TopSleep to inform the user.
#
sub _PrintWarning {
	my ($message) = @_;
	attron($cmdwin, A_REVERSE);
	addstr($cmdwin, 0, 0, "$message");
	attroff($cmdwin, A_REVERSE);
	clrtoeol($cmdwin);
	refresh($cmdwin);
}

#
# Get input from user on commandline.
#
sub _GetString {
	
	my ($question) = @_;
	
	my $input = '';
	my $x = 0;
	
	#
	# Print question in terminal.
	#
	$question .= ' ';
	my $question_length = length($question);
	addstr($cmdwin, 0, 0, $question);
	$x = $question_length;
	clrtoeol($cmdwin);
	refresh($cmdwin);
	nodelay($cmdwin, 0);
	
	#
	# Get answer from user.
	#
	while (1) {
		my ($char, $key) = getch($cmdwin);
		next unless (defined($char));
		if ($char eq ERR) {
			# ERR returned on timeout.
			next;
		#
		# When your terminal is not configured correctly the backspace character may have a different ASCII number.
		# In most but not all cases this is then character number 127 (DEL). Preferably try to fix your terminal config, 
		# but if that does not help, switch the comment for the 2 lines below to treat char 127 as backspace.
		#
		#} elsif ($char eq KEY_BACKSPACE or $char eq "$CTRL_H" or $char eq "\cH" or ord($char) == 127) {
		} elsif ($char eq KEY_BACKSPACE or $char eq "$CTRL_H" or $char eq "\cH") {
			#
			# User corrected typo using backspace.
			#
			#_PrintWarning('DEBUG: KEY_BACKSPACE was pressed but it is mapped to ' . KEY_BACKSPACE);
			if (length($input) > 0) {
				$x--;
				move($cmdwin, 0, $x);
				delch($cmdwin);
				refresh($cmdwin);
				substr($input, $x - $question_length, 1, '');
			}
		} elsif ($char eq KEY_DC) {
			#
			# User corrected typo using delete.
			#
			if (length($input) > 0) {
				delch($cmdwin);
				refresh($cmdwin);
				substr($input, $x - $question_length, 1, '');
			}
		} elsif ($char eq $CTRL_G) {
			#
			# User aborted.
			#
			$input = "";
			last;
		} elsif ($char eq KEY_LEFT) {
			if ($x > $question_length) {
				$x--;
				move($cmdwin, 0, $x);
				refresh($cmdwin);
			}
		} elsif ($char eq KEY_RIGHT) {
			if ($x < $question_length + length($input)) {
				$x++;
				move($cmdwin, 0, $x);
				refresh($cmdwin);
			}
		} elsif ($char eq "\n") {
			#
			# User pressed return/enter.
			#
			last;
		} else {
			my $current_position_offset = $x - $question_length;
			substr($input, $current_position_offset, 0, $char);
			insch($cmdwin, $char);
			$x++;
			move($cmdwin, 0, $x);
			refresh($cmdwin);
		}
	}
	move($cmdwin, 0, 0);
	clrtoeol($cmdwin);
	refresh($cmdwin);
	return $input;
}

sub print_serverstatus_window {
	my $server = shift;
	_DestroySubWindow();
	_PrintWarning('TODO: Not yet implemented for SLURM.');
	return;
	
	my $con = pbs_connect($server);
	if ($con <= 0) {
		_DestroySubWindow();
		_PrintWarning("Connect to $server failed: $PBS::pbs_errno\n");
		return;
	}
	my $ref = pbs_statserver($con, undef, undef);
	pbs_disconnect($con);
	_PrintSubWindow("$server", $ref->[0]->{attribs});
}

# since we don't store enough info about jobs in %jobs, go ahead and get
# it from the server
sub print_jobstatus_window {
	my $job    = shift;
	my $server = shift;
	_DestroySubWindow();
	_PrintWarning('TODO: Not yet implemented for SLURM.');
	return;
	
	my $con = pbs_connect($server);
	if ($con <= 0) {
		_DestroySubWindow();
		_PrintWarning("Connect to $server failed: $PBS::pbs_errno\n");
		return;
	}
	
	my $ref = pbs_statjob($con, "$job.$server", undef, undef);
	pbs_disconnect($con);
	
	_PrintSubWindow("$job.$server", $ref->[0]->{attribs}, "'l' for node load report");

}

#
# We already have everything we need to know about nodes in our big Nodes struct,
# so just pull info from there.
#sub print_nodearch_window {
#	my $nodename = shift or return;
#	my $ref      = shift or return;
#	
#	my (@attrs, $name, $value);
#	while (($name, $value) = each %{ $ref->{'status'} }) {
#		push(@attrs, { name => $name, value => $value });
#	}
#	push(@attrs, { name => 'arch', value => $ref->{'arch'} });
#	push(@attrs, { name => 'state', value => $ref->{'state'} });
#	if (exists $ref->{features}) {
#		push(@attrs, { name => 'features', value => $ref->{'features'} });
#	}
#	
#	# TODO: only offer the 'j' option when only one job running, and not just on CPU0
#	my $multiplejob = 0;
#	foreach my $cpu (
#		sort { $multiplejob ||= $ref->{job}{$a} != $ref->{job}{$b}; $a <=> $b }
#		keys %{ $ref->{job} }
#	  )
#	{
#		push(@attrs, { name => "CPU$cpu: job#", value => $ref->{job}{$cpu} });
#	}
#	
#	#push(@attrs, { name => "multiple", value => $multiplejob });
#	_PrintSubWindow("$nodename", \@attrs, "'j' for job details on CPU0");
#	
#}
#
#
# This is used by the subs above to actually paint the subpad.
#
#sub _PrintSubWindow {
#	
#	my ($title, $ref, $epilogue) = @_;
#	
#	my $line = 1;
#	
#	#
#	# Subwin's width is 8 fewer than the main win, and with 2 chars padding inside,
#	# each line will be 10 chars less wide than the main window.
#	# Select the smallest sizes from default and size currently in use
#	# to make sure the subpad is smaller than its parent pad.
#	# When the dimensions for the subpad are larger than those of the parent,
#	# subpad creating will fail!
#	#
#	my $subpad_width;
#	my $subpad_height;
#	if ($maxcolumns < $X) {
#		$subpad_width = $maxcolumns - 8;
#	} else {
#		$subpad_width = $X - 8;
#	}
#	if ($maxrows < $Y) {
#		$subpad_height = $maxrows - 5;
#	} else {
#		$subpad_height = $Y - 5;
#	}
#	
#	#
#	# TODO: Do we need to properly destroy the subpads?
#	#
#	$subpad = subpad($pad, $subpad_height, $subpad_width, 2, 5);
#	
#	$subpad or die "FATAL: Failed to _PrintSubWindow. X = $X | Y = $Y | maxcolumns = $maxcolumns | maxrows = $maxrows";
#	move($subpad, $line, 0);
#	clrtoeol($subpad);
#	move($subpad, $line, 2);
#	
#	foreach my $attr (@{$ref}) {
#		my $name       = $attr->{name};
#		my $value      = $attr->{value};
#		my $indent     = length($name) + 2 + 3;     # 2 for padding, 3 for " = "
#		my $maxlinelen = $subpad_width - $indent;
#		my $pattern    = ".{1,$maxlinelen}";
#		
#		addstr($subpad, $name . " = ");
#		my $string = $value;
#		
#		if ((length($string) + $indent) > $maxlinelen) {
#			while (length($string)) {
#				move($subpad, $line, $indent);
#				$string =~ s/($pattern)// or die "FATAL: Cannot truncate '$string' to max line length of $maxlinelen characters.";
#				addstr($subpad, "$1");
#				clrtoeol($subpad);
#				move($subpad, ++$line, 0);
#				clrtoeol($subpad);
#				move($subpad, $line, 2);
#			}
#			move($subpad, $line, 0);
#			clrtoeol($subpad);
#			move($subpad, $line, 2);
#		} else {
#			addstr($subpad, $string);
#			clrtoeol($subpad);
#			move($subpad, ++$line, 0);
#			clrtoeol($subpad);
#			move($subpad, $line, 2);
#		}
#	}
#	
#	move($subpad, ++$line, 0);
#	clrtoeol($subpad);
#	move($subpad, $line, 2);
#	if (defined $epilogue) {
#		addstr($subpad, "'q' to exit $epilogue");
#	} else {
#		addstr($subpad, "'q' to exit this window");
#	}
#	move($subpad, ++$line, 0);
#	clrtoeol($subpad);
#	
#	#
#	# Create a nice box by adding a border to the window.
#	#
#	resize($subpad, $line + 2, $X - 10);
#	attron($subpad, COLOR_PAIR(1));
#	box($subpad, &ACS_VLINE, &ACS_HLINE);
#	move($subpad, 0, 3);
#	addch($subpad, &ACS_RTEE);
#	addstr($subpad, "$title");
#	addch($subpad, &ACS_LTEE);
#	attroff($subpad, COLOR_PAIR(1));
#	
#	# currently not used (since the subwin is always smaller than the terminal)
#	$sub_Y = $line + 4;
#	$sub_X = $X - 10;
#
#}

sub _UpdateSubWindow {
	$subpad or return;
	#pnoutrefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
	pnoutrefresh($subpad_box, 0, 0, 0, 0, $sub_Y, $sub_X);
	pnoutrefresh($subpad_content, $sub_partial_y , $sub_partial_x, 2, 2, $sub_Y - 3, $sub_X - 3);
	#pnoutrefresh($subpad, 0, 0, 0, 0, $sub_Y - 1, $sub_X - 1);
	doupdate();
	#prefresh($subpad, 0, 0, 0, 0, $sub_Y, $sub_X);
}

sub _DestroySubWindow {
	delwin($subpad_content);
	delwin($subpad_box);
	delwin($subpad);
	$subpad         = 0;
	$subpad_box     = 0;
	$subpad_content = 0;
	$sub_partial_y  = 0;
	$sub_partial_x  = 0;
	$sub_Y  = 0;
	$sub_X  = 0;
	if ($partial_y >= $last_y - $Y + 2) {
		$partial_y = $last_y - $Y + 3;
		pnoutrefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
	}
}

sub _PrintHelpPad {
	
	my $title = 'Settings & Help';
	my $line = 1;
	my $color_pair = 3;
	my $indent = '  ';
	
	#
	# Get dimensions for subpads.
	#
	# When the dimensions for the subpad are larger than those of the parent,
	# subpad creating will fail!
	#
	my $sub_width;
	my $sub_height;
	my $box_width;
	my $box_height;
	my $content_width   = 152; # Not yet dynamically determined based on content. When value is too small content will be clipped.
	my $content_height  = 72;  # Not yet dynamically determined based on content. When value is too small content will be clipped.
	
	if ($maxcolumns < $X) {
		$box_width = $maxcolumns;
	} else {
		$box_width = $X;
	}
	if ($maxrows < $Y) {
		$box_height = $maxrows;
	} else {
		$box_height = $Y - 1;
	}
	
	if ($content_width + 2 < $box_width) {
		$sub_width = $box_width;
	} else {
		$sub_width = $content_width + 2;
	}
	if ($content_height + 2 < $box_height) {
		$sub_height = $box_height;
	} else {
		$sub_height = $content_height + 2;
	}
	$sub_Y = $box_height;
	$sub_X = $box_width;
	$sub_last_y = $content_height;
	$sub_last_x = $content_width;
	
	#
	# Create subpads.
	#
	$subpad         = newpad($sub_height, $sub_width);
	$subpad_box     = newpad($box_height, $box_width);
	$subpad_content = subpad($subpad, $content_height, $content_width , 2, 2);
	$subpad         or die "FATAL: Failed to create subpad in _PrintHelpPad. X = $X | Y = $Y | sub_height = $sub_height | sub_width = $sub_width";
	$subpad_box     or die "FATAL: Failed to create subpad_box in _PrintHelpPad. X = $X | Y = $Y | sub_height = $sub_height | sub_width = $sub_width | box_height = $box_height | box_width = $box_width";
	$subpad_content or die "FATAL: Failed to create subpad_content in _PrintHelpPad. X = $X | Y = $Y | sub_height = $sub_height | sub_width = $sub_width | con_height = $content_height | con_width = $content_width";
	clrtobot($subpad);
	clrtobot($subpad_content);
	clrtobot($subpad_box);
	
	#
	# Create a nice box by adding a border to the window.
	#
	attron($subpad_box, COLOR_PAIR($color_pair) | A_BOLD);
	box($subpad_box, &ACS_VLINE, &ACS_HLINE);
	move($subpad_box, 0, 3);
	addch($subpad_box, &ACS_RTEE);
	attron($subpad_box, A_REVERSE);
	addstr($subpad_box, " $title ");
	attroff($subpad_box, A_REVERSE);
	addch($subpad_box, &ACS_LTEE);
	attroff($subpad_box, COLOR_PAIR($color_pair) | A_BOLD);
	
	#
	# Add content to the window.
	#
	addstr($subpad_content, 'Current settings:');
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Version ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $VERSION);
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Refresh ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $sleeptime . ' seconds');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Grid width ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $columns . ' cores');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Colorization ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $colorize ? 'on' : 'off');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	if ($colorize) {
		addstr($subpad_content, $indent . 'Color by ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, $color_by);
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
	}
	addstr($subpad_content, $indent . 'State summary display ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $show_summary ? 'on' : 'off');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Grid display ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $show_grid ? 'on' : 'off');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Display jobs in grid ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $show_jobs ? 'on' : 'off');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Load = ');
	attron($subpad_content, A_BOLD | COLOR_PAIR(2)) if ($colorize);
	addstr($subpad_content, 'Ok');
	attroff($subpad_content, A_BOLD | COLOR_PAIR(2)) if ($colorize);
	addstr($subpad_content, '        indicates ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, 'requested cores - ' . $healthy_load_stdev . ' <= load <= requested cores + ' . $healthy_load_stdev);
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Load = ');
	attron($subpad_content, A_BOLD | COLOR_PAIR(3)) if ($colorize);
	addstr($subpad_content, 'too low!');
	attroff($subpad_content, A_BOLD | COLOR_PAIR(3)) if ($colorize);
	addstr($subpad_content, '  indicates ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, 'load < requested cores - ' . $healthy_load_stdev);
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Load = ');
	attron($subpad_content, A_BOLD | COLOR_PAIR(1)) if ($colorize);
	addstr($subpad_content, 'TOO HIGH!');
	attroff($subpad_content, A_BOLD | COLOR_PAIR(1)) if ($colorize);
	addstr($subpad_content, ' indicates ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, 'load > requested cores + ' . $healthy_load_stdev);
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Showing jobs from: ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, join(" ", @clusters));
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Queue display ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $show_queue ? 'on' : 'off');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Show queued jobs ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $show_qqueue ? 'on' : 'off');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	if ($colorize) {
		addstr($subpad_content, $indent . 'CPU/Mem ');
		attron($subpad_content, A_BOLD | COLOR_PAIR(2));
		addstr($subpad_content, 'healthy resource usage ');
		attroff($subpad_content, A_BOLD | COLOR_PAIR(2));
		addstr($subpad_content, ' indicates ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, $res_usage_low . ' <= (used / requested) <= ' . $res_usage_high);
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
		
		addstr($subpad_content, $indent . 'CPU/Mem ');
		attron($subpad_content, A_BOLD | COLOR_PAIR(3)) if ($colorize);
		addstr($subpad_content, 'inefficiently low usage');
		attroff($subpad_content, A_BOLD | COLOR_PAIR(3)) if ($colorize);
		addstr($subpad_content, ' indicates ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, '(used / requested) < ' . $res_usage_low);
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
		
		addstr($subpad_content, $indent . 'CPU/Mem ');
		attron($subpad_content, A_BOLD | COLOR_PAIR(1)) if ($colorize);
		addstr($subpad_content, 'dangerously high usage ');
		attroff($subpad_content, A_BOLD | COLOR_PAIR(1)) if ($colorize);
		addstr($subpad_content, ' indicates ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, '(used / requested) > ' . $res_usage_high);
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
	}
	addstr($subpad_content, $indent . 'Number of possible colors ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, "$COLOR_PAIRS\n");
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	if ($show_user) {
		addstr($subpad_content, $indent . 'Limiting job view to user(s) ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, "$show_user\n");
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
	}
	if ($show_node) {
		addstr($subpad_content, $indent . 'Limiting job view to node(s) ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, "$show_node\n");
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
	}
	if ($show_job_id && $show_job_id ne '!') {
		my @jobs_selected = split(' ', $show_job_id);
		my $job_count = scalar(@jobs_selected);
		addstr($subpad_content, $indent . 'Limiting job view to ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, $job_count . ' job(s) from search result.' . "\n");
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
	}
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, 'Navigation:');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Press [Arrow], [Page Up], [Page Down], [Home] or [End] keys to navigate.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . $indent . 'Depending on your terminal settings you may have to press ');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	addstr($subpad_content, $indent . $indent . 'a modifier key ([Alt], [Ctrl] or [Shift]) + a navigation key to scroll.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, 'Interactive commands are:');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '[space] Update Display.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'q       Quit.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'h       Print this Help.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'c       Color cores in grid display by job, user, queue or resource usage.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'd       Toggle dense (more compact) grid display.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'u       Show only jobs for a subset of Users.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts comma seprated list for multiple users.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'n       Show only jobs for a subset of Nodes.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts comma separated list for multiple nodes (e.g. 02,05,10).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts dash separated range of node (e.g. 02-07).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 's       Seconds to refresh.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 't       Toggle display of in-active (queued or finished) jobs in the queue display.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Active jobs include jobs with job states:');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	foreach my $known_job_state (sort(keys(%known_job_states))) {
		if ($known_job_states{$known_job_state}{'consumes_resources'}) {
			addstr($subpad_content, $indent . sprintf('              %-2s - %-12s: %s', $known_job_state, $known_job_states{$known_job_state}{'name'}, $known_job_states{$known_job_state}{'desc'}));
			clrtoeol($subpad_content);
			move($subpad_content, ++$line, 0);
		}
	}
	
	addstr($subpad_content, $indent . '           In-active jobs include jobs with job states:');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	foreach my $known_job_state (sort(keys(%known_job_states))) {
		if (! $known_job_states{$known_job_state}{'consumes_resources'}) {
			addstr($subpad_content, $indent . sprintf('              %-2s - %-12s: %s', $known_job_state, $known_job_states{$known_job_state}{'name'}, $known_job_states{$known_job_state}{'desc'}));
			clrtoeol($subpad_content);
			move($subpad_content, ++$line, 0);
		}
	}
	
	addstr($subpad_content, $indent . 'j       Toggle display of Jobs in grid display.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'w       With of grid display in number of cores.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '/       Search jobs and display details. Search is not case sensitive.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts i: prefix to limit search to job IDs (e.g. i:251).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts j: prefix to limit search to job names (e.g. j:MyExperiment).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts n: prefix to limit search to jobs running on a node (e.g. n:3).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts c: prefix to limit search to jobs from a cluster (e.g. s:calculon).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts u: prefix to limit search to jobs from certain users (e.g. u:myaccount).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts q: prefix to limit search to jobs submitted to certain QoS level (e.g. q:priority).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'C       Toggle Colorization.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'S       Toggle State summary.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'G       Toggle Grid display.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Q       Toggle Queue display.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	if ($content_height != $line) {
		_PrintWarning('WARN: window size not calculated correctly. content_height is ' . $content_height . ', but we counted ' . $line . ' lines.');
	}
	
	_UpdateSubWindow(@_);
	
	_PrintWarning('Press any non-navigation key to exit this ' . $title . ' window...');
	
	#
	# Wait for the user to hit the any key.
	#
	#cbreak;
	#nodelay($helpwin, 0);
	#getch($helpwin);
	#halfdelay(1);
	#prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
	#move($cmdwin, 0, 0);
	#clrtoeol($cmdwin);
	#refresh($cmdwin);
	#delwin($helpwin);
	
}

sub _PerformSearch {
	
	my ($search_pattern, $jobs) = @_;
	my @job_ids_found;
	my $object_type;
	
	#
	# Did the user disable the filtering by providing an empty search pattern of searching for '.*'?
	#
	if ((!defined($search_pattern)) or $search_pattern =~ m/^\n*$/) {
		$show_job_id = 0;
		_PrintWarning('INFO: disabled search; showing all jobs.');
		return;
	} elsif ($search_pattern =~ s/^([a-z])://) {
		#
		# Did the user specify an object type to limit the search?
		#
		if ($1 eq 'i') {
			$object_type = 'JobID';
		} elsif ($1 eq 'j') {
			$object_type = 'JobName';
		} elsif ($1 eq 'n') {
			$object_type = 'Node';
		} elsif ($1 eq 'c') {
			$object_type = 'Cluster';
		} elsif ($1 eq 'u') {
			$object_type = 'User';
		} elsif ($1 eq 'q') {
			$object_type = 'QoS';
		} else {
			_PrintWarning('ERROR: Invalid search pattern prefix.');
			return;
		}
	} else {
		$object_type = 'Any';
	}
	
	#
	# Reset job ID filter -> show nothing.
	#
	$show_job_id = '';
	
	#
	# Search for relevant objects in the data structure for all jobs and all nodes.
	#
	foreach my $job (keys(%{$jobs})) {
		my $found = 0;
		my $job_name = ${$jobs}{$job}{'jname'};
		my $user     = ${$jobs}{$job}{'user'};
		my $qos      = ${$jobs}{$job}{'qos'};
		my $cluster  = ${$jobs}{$job}{'cluster'};
		if ($object_type eq 'JobID' || $object_type eq 'Any') {
			my $job_id_pattern = $search_pattern;
			if ($search_pattern =~ m/^(.+)\.[^\+\*\?\.]+$/) {
				$job_id_pattern = $1;
			}
			if ($job =~ m/$job_id_pattern/i and (!defined($cluster) or ${$jobs}{$job}{'cluster'} =~ m/$cluster/)) {
				$found = 1;
			}
		}
		if ($object_type eq 'JobName' || $object_type eq 'Any') {
			if ($job_name =~ m/$search_pattern/i) {
				$found = 1;
			}
		}
		if ($object_type eq 'Node' || $object_type eq 'Any') {
			if (defined(${$jobs}{$job}{'node'})) {
				my $node_pattern = $search_pattern;
				if ($search_pattern =~ m/^(.+)\.[^\+\*\?\.]+$/) {
					$node_pattern = $1;
				}
				if (${$jobs}{$job}{'node'} =~ m/$node_pattern/i and (!defined($cluster) or ${$jobs}{$job}{'cluster'} =~ m/$cluster/)) {
					$found = 1;
				}
			}
		}
		if ($object_type eq 'Cluster' || $object_type eq 'Any') {
			if (${$jobs}{$job}{'cluster'} =~ m/$search_pattern/i) {
				$found = 1;
			}
		}
		if ($object_type eq 'User' || $object_type eq 'Any') {
			if ($user =~ m/$search_pattern/i) {
				$found = 1;
			}
		}
		if ($object_type eq 'QoS' || $object_type eq 'Any') {
			if ($qos =~ m/$search_pattern/i) {
				$found = 1;
			}
		}
		
		if ($found) {
			push (@job_ids_found, $job);
		}
	}
	
	#
	# Create space separated list of job IDs for the matching jobs 
	# that will be diplayed on referesh of the display.
	#
	foreach my $job (@job_ids_found) {
		$show_job_id   .= $job . ' ';
	}
	$show_job_id   =~ s/ $//;
	
	#
	# Check if we found anything.
	#
	my $jobs_found = scalar(@job_ids_found);
	if ($jobs_found < 1) {
		$show_job_id = '!';
		_PrintWarning('WARN: No objects found matching ' . $search_pattern);
	} else {
		_PrintWarning('INFO: found ' . $jobs_found . ' job(s) matching ' . $search_pattern);
	}
	
}

#
# Loop around processing user input until the timer expires 
# and it is time to return back up to _MainLoop() for an update.
#
sub _TopSleep {
	
	my $targettime = time() + $sleeptime;
	
	while (time() < $targettime) {
		halfdelay(1);
		my $input = getch($cmdwin);
		if ($SIGWINCH) {
			$SIGWINCH = 0;
			endwin;
			refresh();
			_UpdateDisplay(@_);
		}
		if (defined($input)) {
			if ($input eq KEY_HOME or $input eq KEY_SHOME or $input eq KEY_FIND) {
				if ($subpad) {
					$sub_partial_y = 0;
					$sub_partial_x = 0;
					_UpdateSubWindow();
				} else {
					$partial_y = 0;
					$partial_x = 0;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq KEY_END or $input eq KEY_SEND or $input eq KEY_SELECT) {
				if ($subpad) {
					$sub_partial_y = $sub_last_y + 4 - $sub_Y;
					$sub_partial_x = 0;
					_UpdateSubWindow();
				} else {
					$partial_y = $last_y + 2 - $Y;
					$partial_x = 0;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq KEY_PPAGE or $input eq KEY_SPREVIOUS or $input eq $CTRL_B) {
				if ($subpad) {
					$sub_partial_y -= $sub_Y - 4;
					$sub_partial_y <= 0 and $sub_partial_y = 0;
					_UpdateSubWindow();
				} else {
					$partial_y -= $Y - 2;
					$partial_y <= 0 and $partial_y = 0;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq KEY_NPAGE or $input eq KEY_SNEXT or $input eq $CTRL_F) {
				if ($subpad_box) {
					$sub_partial_y += $sub_Y - 4;
					$sub_partial_y >= $sub_last_y - $sub_Y + 4 and $sub_partial_y = $sub_last_y - $sub_Y + 4;
					_UpdateSubWindow();
				} else {
					$partial_y += $Y - 2;
					$partial_y >= $last_y - $Y + 2 and $partial_y = $last_y - $Y + 2;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq '8' or $input eq KEY_UP) {
				if ($subpad) {
					$sub_partial_y <= 0 and $sub_partial_y = 0, next;
					$sub_partial_y--;
					_UpdateSubWindow();
				} else {
					$partial_y <= 0 and $partial_y = 0, next;
					$partial_y--;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq '2' or $input eq KEY_DOWN) {
				if ($subpad) {
					$sub_partial_y >= $sub_last_y - $sub_Y + 4 and next;
					$sub_partial_y++;
					_UpdateSubWindow();
				} else {
					$partial_y >= $last_y - $Y + 2 and next;
					$partial_y++;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq '4' or $input eq KEY_LEFT) {
				if ($subpad) {
					$sub_partial_x <= 0 and $partial_x = 0, next;
					$sub_partial_x--;
					_UpdateSubWindow();
				} else {
					$partial_x <= 0 and $partial_x = 0, next;
					$partial_x--;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq '6' or $input eq KEY_RIGHT) {
				if ($subpad) {
					$sub_partial_x >= $sub_last_x - $sub_X and next;
					$sub_partial_x++;
					_UpdateSubWindow();
				} else {
					$partial_x >= $last_x - $X and next;
					$partial_x++;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($subpad && $input ne '-1') {
				#
				# User pressed the "any" key to close a sub window...
				#
				_DestroySubWindow();
				_UpdateDisplay(@_);
				clear($cmdwin);
				move($cmdwin, 0, 0);
				refresh($cmdwin);
				#_PrintWarning('DEBUG: input was: ' . $input . '.');
			} elsif ($input eq 'q') {
				endwin;
				exit(0);
			} elsif ($input eq $CTRL_L) {
				# Why doesn't curses do this automatically?
				clear($pad);
				clrtoeol($cmdwin);
				_UpdateDisplay(@_);
			} elsif ($input eq 'h' || $input eq '?') {
				_PrintHelpPad();
#			} elsif ($input =~ /^\d$/) {
#				# Change the visible CPUs.
#				# TODO: Don't allow the user to display CPUs that don't exist on any node.
#				# TODO: Currently disabled as we have only one (virtual) CPU with many cores.
#				if (grep /^$input$/, @show_cpu) {
#					@show_cpu = grep !/$input$/, @show_cpu;
#				} else {
#					my %seen = ();
#					foreach (@show_cpu, $input) {
#						$seen{$_} = 1;
#					}
#					@show_cpu = sort keys %seen;
#				}
#				_UpdateDisplay(@_);
			} elsif ($input eq 's') {
				if ($subpad) {
					_DestroySubWindow();
					_UpdateDisplay(@_);
					return;
				}
				$input = _GetString('Number of seconds for refresh? ' . "[$sleeptime] ");
				if ($input =~ m/^\d+$/ && $input >= 1) {
					$sleeptime = $input;
					$targettime = time() + $sleeptime;
				} else {
					_PrintWarning('ERROR: Invalid number!');
				}
			} elsif ($input eq 'w') {
				$input = _GetString('Width of grid display in number of cores ? ' . "[$columns] ");
				if ($input) {
					if ($input =~ /^\d+$/ and $input > 0) {
						$columns = $input;
						_UpdateDisplay(@_);
					} else {
						_PrintWarning('ERROR: Invalid number!');
					}
				}
			} elsif ($input eq 'd') {
				$dense_grid = !$dense_grid;
				_UpdateDisplay(@_);
			} elsif ($input eq 'u') {
				$input = _GetString('Limit view to "a" for all, "me" for the current user, or comma separated list of users? ');
				if ($input) {
					if ($input eq 'all' or $input eq 'a') {
						$show_user = 0;
					} elsif ($input eq 'me' or $input eq 'm') {
						$show_user = $ENV{USER};
					} elsif ($input =~ /^\+(.*)/) {
						if ($show_user eq '0') {
							_PrintWarning('ERROR: Cannot add user to list of users. Please specify a list first.');
							return;
						}
						if ($1 eq 'me' or $1 eq 'm') {
							$show_user .= ' ' . $ENV{USER};
						} else {
							$show_user .= " $1";
						}
						$show_user =~ s/^ / /g;
					} elsif ($input =~ /^-(.*)/) {
						if ($show_user eq '0') {
							_PrintWarning('ERROR: Cannot remove user from list of users. Please specify a list first.');
							return;
						}
						if ($1 eq 'me' or $1 eq 'm') {
							$show_user =~ s/\b$ENV{USER}\b//;
						} else {
							$show_user =~ s/\b$1\b//;
						}
						$show_user =~ s/  / /g;
						$show_user =~ s/^ / /g;
						$show_user =~ s/ $/ /g;
					} else {
						$show_user = $input;
					}
					_UpdateDisplay(@_);
				}
			} elsif ($input eq 'n') {
				$input = _GetString('Limit view to "a" for all nodes, range or comma separated list of nodes? ');
				if ($input) {
					if ($input eq 'all' or $input eq 'a') {
						$show_node = 0;
					} elsif ($input =~ m/^\+(.*)/) {
						if ($show_node eq '0') {
							_PrintWarning('ERROR: Cannot add node to list of nodes. Please specify a list first.');
							return;
						}
						$show_node .= " $1";
						$show_node =~ s/^ / /g;
					} elsif ($input =~ m/^-(.*)/) {
						if ($show_node eq '0') {
							_PrintWarning('ERROR: Cannot remove node from list of nodes. Please specify a list first.');
							return;
						}
						$show_node =~ s/\b$1\b//;
						$show_node =~ s/  / /g;
						$show_node =~ s/^ / /g;
						$show_node =~ s/ $/ /g;
					} elsif ($input =~ m/^([^0-9]*)([0-9]+)-([^0-9]*)([0-9]+)$/) {
						my $name_prefix = $1;
						my $start = $2;
						my $stop  = $4;
						$show_node = '';
						foreach my $i ($start..$stop) {
							$show_node .= $name_prefix . $i . ' ';
						}
						$show_node =~ s/\s$//;
					} else {
						$show_node = $input;
					}
					_UpdateDisplay(@_);
				}
			} elsif ($input eq 'c') {
				if (!has_colors()) {
					_PrintWarning('ERROR: Terminal doesn\'t support colors.');
					$colorize = 0;
				} else {
					# Toggle colorize if color was disabled.
					$colorize = !$colorize unless ($colorize);
					# Get item type to group by for coloring nodes in grid display 
					$input = _GetString('Color jobs by "j" (job), "u" (user), "q" (QoS) or "r" (resource usage)? ' . "[$color_by]");
					if ($input) {
						if ($input eq 'job' or $input eq 'j') {
							$color_by = 'job';
						} elsif ($input eq 'user' or $input eq 'u') {
							$color_by = 'user';
						} elsif ($input eq 'qos' or $input eq 'q') {
							$color_by = 'qos';
						} elsif ($input eq 'resource usage' or $input eq 'r') {
							$color_by = 'resources';
						} else {
							_PrintWarning('ERROR: Unsupported color by value.');
						}
						_UpdateDisplay(@_);
					}
				}
			} elsif ($input eq 'C') {
				$colorize = !$colorize;
				if ($colorize && !has_colors()) {
					_PrintWarning('ERROR: Terminal doesn\'t support colors.');
					$colorize = 0;
				}
				_UpdateDisplay(@_);
			} elsif ($input eq 'S') {
				$show_summary = !$show_summary;
				_UpdateDisplay(@_);
			} elsif ($input eq 'G') {
				$show_grid = !$show_grid;
				_UpdateDisplay(@_);
			} elsif ($input eq 'Q') {
				$show_queue = !$show_queue;
				_UpdateDisplay(@_);
			} elsif ($input eq 't') {
				$show_qqueue = !$show_qqueue;
				_UpdateDisplay(@_);
			} elsif ($input eq 'j') {
				$show_jobs = !$show_jobs;
				_UpdateDisplay(@_);
			} elsif ($input eq ' ') {
				addstr($cmdwin, 0, 0, "Updating...");
				clrtoeol($cmdwin);
				refresh($cmdwin);
				move($cmdwin, 0, 0);
				clrtoeol($cmdwin);
				return;
			} elsif ($input eq '/') {
				$input = _GetString('Search string? ');
				_PerformSearch($input, $_[3]);
				_UpdateDisplay(@_);
			} elsif ($input =~ m/^\n$/) {
				#
				# User pressed the enter key.
				# Most likely to get rid of an error/warning message.
				# Just update the screen.
				#
				addstr($cmdwin, 0, 0, '');
				clrtoeol($cmdwin);
				refresh($cmdwin);
				move($cmdwin, 0, 0);
				clrtoeol($cmdwin);
				#return;
			} elsif ($input =~ m/[^\d\.-]/) {
				_PrintWarning('ERROR: unsupported command ' . $input . '.');
				return;
			}
			#_PrintWarning("DEBUG: y = $y | x = $x | Y = $Y | X = $X | p_y = $partial_y | p_x = $partial_x | l_y = $last_y | l_x = $last_x | sub_Y = $sub_Y | sub_X = $sub_X | s_p_y = $sub_partial_y | s_p_x = $sub_partial_x.");
		}
	}
}

sub _LoadConfig {
	my ($config_file) = @_ or return;
	return unless (-f $config_file);
	
	open(F, $config_file) or die "$config_file: $!\n";
	while ($_ = <F>) {
		chomp;
		s/#.*//;
		next unless $_;
		my ($name, $value) = split(/=/);
		$name  =~ s/\s//g;
		$value =~ s/\s//g;
		next if (length($name) <= 0 or length($value) <= 0);
		
		#
		# TODO: security risk: get rid of eval.
		#
		if ($name eq "cluster") {
			eval "\@$name=(\"" . join('","', split(',', $value)) . "\")";
		} elsif ($name eq "show_user") {
			eval "\$$name=join(' ', split(',', \"$value\"))";
		} else {
			eval "\$$name=$value";
		}
	}
	close(F);
}

__END__

=head1 NAME

ctop - cluster monitoring utility for SLURM

=head1 SYNOPSIS

ctop [OPTION]... [@cluster]...

=head1 DESCRIPTION

Draws a full-terminal display of your nodes and jobs. 
The default grid shows each CPU core on each node as a single character. 
The specific character denotes the state of the node or identifies the job running on that CPU. 
The job listing shows the job ID, user name, Quality of Service QoS level, job name, job state and resources requested vs. resources used.
For running jobs this line is preceeded by the character used to identify the cores consumed by the job on nodes in the upper grid.

This program requires Perl, the Perl Curses module, a curses library like ncurses and the SLURM commandline tools:
 * scontrol
 * sinfo
 * squeue
 * sstat
In order for sstat to be able to report info for jobs from all users you must run a patched slurmd daemon on the compute nodes.


=head1 COMMAND-LINE OPTIONS

=over 4

=item   B<-s> num

seconds between refreshes

=item   B<-w> num

number of columns to display in the grid

=item   B<-u>

usernames for limiting the view of the grid and job list.
Can be a comma-seperated list of usernames or C<all>. 
C<me> is a pseudonym for the user running ctop(1).

=item   B<-C>

toggle colorization

=item   B<-S>

toggle state summary display

=item   B<-G>

toggle grid display

=item   B<-Q>

toggle queue display

=item   B<-t>

toggle showing queued jobs in queue display

=item   B<-j>

toggle jobs in grid display

=item   B<-V>

print version and exit

=back

=head1 INTERACTIVE COMMANDS

Several single-key commands are recognized while ctop(1) is running.
The arrow keys, PageUp, and PageDown keys will scroll the display if it doesn't fit in your terminal.

When prompted to type something, ctrl-g can be used to cancel the command.

=over 4

=item   B<space>

Refresh display immediately.

=item B<q>

Quit ctop(1)

=item B<h>

Display help screen, version, and current settings.

=item B<c>

Prompts for the number of columns (representing cores) to display the node grid.

=item B<s>

Prompts for the number of seconds to wait between display updates.

=item B<u>

Prompts for a username. The grid and job listing will be limited to the named user. 
Input C<all> will remove all limitations (the default), and C<me> will limit to the current username running ctop(1). 
If the username or C<me> is prefixed with a C<+> or C<->, 
the username will be added or removed from the list of usernames to be limited. 
C<a> and C<m> are shortcuts for C<all> and C<me>.

=item B</>

Prompts the user for a search string.
The search can optionally begin with one of the following pattern specifiers:
C<~c> for a cluster, C<~n> for a node, or C<~j> for a job number.
If no pattern specifier is found, ctop will attempt to find the object that best matches the search string. 
The string can be a cluster name, nodename, or a job number. 

=item B<C>

Toggle the use of the colors in the display.

=item B<S>

Toggle the display of the state summary.

=item B<G>

Toggle the display of the node grid.

=item B<d>

Toggle dense (more compact) display of the node grid.

=item B<Q>

Toggle the display of the job queue.

=item B<t>

Toggle the display of currently queued (not running) jobs in the display. 
This can reduce the size of the queue display considerably in some environments.

=item B<j>

Toggle the display of job letters in the node grid.  This handy because you can
see the node state "hidden" behind the job letter.  For example, use this to
see which nodes are not yet "busy" that have jobs.

=back

=head1 STARTUP

ctop(1) has many configuration variables that can set on the command line, interactively, or from configuration files. 
When ctop(1) starts, it first initializes these variables with built-in defaults, then reads in F</etc/ctoprc>, 
then reads F<~/.ctoprc>, and finally parses the command line arguments. 
Note that several of the command line arguments and interactive
commands are toggles, they don't directly set the value of the configuration.
In contrast, the configuration files are not toggles.

The configuration files may contain following name=value pairs:

=over 4

=item B<columns>

Number of columns in the node grid, positive integer

=item B<sleeptime>

Number of seconds to pause between display updates, positive integer

=item B<colorize>

Use colors in the display, 1 or 0

=item B<show_summary>

Display the summary at the top of the display, 1 or 0

=item B<show_grid>

Show the node grid, 1 or 0

=item B<show_queue>

Show the job queue, 1 or 0

=item B<show_qqueue>

Show queued (not running) jobs in the queue display, 1 or 0

=item B<show_jobs>

Show job and color information in the node grid, 1 or 0

=item B<show_user>

Usernames to limit the view in the grid and job list. 
Can be a comma-seperated list of users, C<all>, or C<me>.

For large sites reasonbable defaults may be C<show_user=me> in F</etc/ctoprc>
and for admin users to have C<show_user=all> in their own F<~/.ctoprc> to limit the data

Members of a group might want all of their teammate's usernames in their own F<~/.ctoprc>.

=item B<cluster>

Comma seperated list of SLURM cluster names.

=item B<maxrows>

Number of rows in the large scrollable panel.

=item B<maxcolums>

Number of columns in the large scollable panel.

=item B<maxnodegrid>

Nodes with more than this number of CPUs will be represented by a seperate grid.

=back

A sample configuration file:

    # I'm grumpy and don't like color
    colorize=0

    # my 6 CPU machine should get a seperate grid
    maxnodegrid=5

    # All of my clusters. (This will only work when data for all these sites can be queried/retrieved from the host running ctop!)
    cluster=calculon,bigbird,testhpc

=head1 MPI ENVIRONMENTS

ctop(1) is currently limited to display jobs running on a single node. 
Support for MPI jobs distributed over multiple nodes is not implemented yet. 

=head1 FILES

=over 4

=item F</etc/ctoprc>

The global configuration file  

=item F<~/.ctoprc>

The personal configuration file.

=back

=head1 SEE ALSO

=over 4

=item slurm.conf, sinfo, squeue, sstat, scontrol

=back

=head1 BUGS

Info is retrieved from multiple SLURM commands. As these are executed sequentially and not simultaneously the returned info may be out of sync...
Hence a node may list a certain number of cores being used, but when one of the jobs using some of those cores finishes 
just between requesting info for nodes and requesting info for jobs, the amount of cores allocated to jobs on that node may mismatch the amount of cores used on that node.

